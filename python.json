{
    "for": {
        "prefix": "for.Py",
        "body": [
            "for $1 in $2:",
            "    $3"
        ],
        "description": "for"
    },
    "forRange": {
        "prefix": "for.RangePy",
        "body": [
            "for $1 in range($2):",
            "    $3"
        ],
        "description": "for with range(0, n-1)"
    },
    "while": {
        "prefix": "whilePy",
        "body": [
            "while $1:",
            "    $2"
        ],
        "description": "while"
    },
    "if": {
        "prefix": "if.Py",
        "body": [
            "if $1:",
            "    $2"
        ],
        "description": "if"
    },
    "ifElse": {
        "prefix": "if_ElsePy",
        "body": [
            "if $1:",
            "    $2",
            "else:",
            "    $3"
        ],
        "description": "ifElse"
    },
    "elif": {
        "prefix": "elifPy",
        "body": [
            "if $1:",
            "    $2",
            "elif $3:",
            "    $4"
        ],
        "description": "elif"
    },
    "emptyList": {
        "prefix": "List_EmptyPy",
        "body": [
            "${1:list_name} = []"
        ],
        "description": "emptyList"
    },
    "List": {
        "prefix": "List.Py",
        "body": [
            "${1:list_name} = [$2]"
        ],
        "description": [
            "List items are ordered, changeable and allow duplicate values",
            "List items are indexed, the first item has index [0], the second item has index [1] etc."
        ]
    },
    "dict": {
        "prefix": "dictPy",
        "body": [
            "${1:dictionary_name} = {",
            "    $2: $3,",
            "    $4: $5",
            "}"
        ],
        "description": [
            "A dictionary is a collection which is ordered (As of Python version 3.7, dictionaries are ordered.",
            "In Python 3.6 and earlier, dictionaries are unordered), changeable and does not allow duplicates.",
            "Dictionary items are presented in key:value pairs, and can be referred to by using the key name."
        ]
    },
    "print": {
        "prefix": "print.Py",
        "body": [
            "print($1)"
        ],
        "description": "print"
    },
    "printString": {
        "prefix": "print_StrPy",
        "body": [
            "print(\"$1\")"
        ],
        "description": "printString"
    },
    "printSep": {
        "prefix": "print_SepPy",
        "body": [
            "print($1, $2, sep=\"$3\")"
        ],
        "description": "printSep"
    },
    "printEnd": {
        "prefix": "print_EndPy",
        "body": [
            "print($1, end=\"$2\")"
        ],
        "description": "printEnd"
    },
    "def": {
        "prefix": "defPy",
        "body": [
            "def ${1:function_name}($2):",
            "    $3 "
        ],
        "description": "def"
    },
    "castInt": {
        "prefix": "cast.IntPy",
        "body": [
            "int($1)"
        ],
        "description": "castInt"
    },
    "castFloat": {
        "prefix": "castFloatPy",
        "body": [
            "float($1)"
        ],
        "description": "castFloat"
    },
    "castStr": {
        "prefix": "cast.StrPy",
        "body": [
            "str($1)"
        ],
        "description": "castStr"
    },
    "tuple": {
        "prefix": "tuplePy",
        "body": [
            "${1:tuplename} = ($2, $3)"
        ],
        "description": [
            "A tuple is a collection which is ordered, unchangeable and allow duplicate values",
            "Tuple items are indexed, the first item has index [0], the second item has index [1] etc."
        ]
    },
    "set": {
        "prefix": "setPy",
        "body": [
            "${1:setname} = {$2, $3}"
        ],
        "description": "Set items are unordered (so you cannot be sure in which order the items will appear), unchangeable and do not allow duplicate values."
    },
    "class": {
        "prefix": "classPy",
        "body": [
            "class ${1:ClassName}:",
            "    $2"
        ],
        "description": "class"
    },
    "tryExceptEmpty": {
        "prefix": "try.Except.EmptyPy",
        "body": [
            "try:",
            "    $1",
            "except:",
            "    $2"
        ],
        "description": "tryExceptEmpty"
    },
    "tryExcept": {
        "prefix": "try.ExceptPy",
        "body": [
            "try:",
            "    $1",
            "except $2:",
            "    $3"
        ],
        "description": "tryExcept"
    },
    "input": {
        "prefix": "inputPy",
        "body": [
            "input($1)"
        ],
        "description": "input"
    },
    "multiPoundComment": {
        "prefix": "comment.Multi.PoundPy",
        "body": [
            "# $1",
            "# $2"
        ],
        "description": "multiPoundComment"
    },
    "multiLineComment": {
        "prefix": "comment.Multi.LinePy",
        "body": [
            "\"\"\"",
            "$1",
            "$2",
            "\"\"\""
        ],
        "description": "multiLineComment"
    },
    "type": {
        "prefix": "typePy",
        "body": [
            "type($1)"
        ],
        "description": "You can get the data type of a variable with the type() function."
    },
    "oneParamLambda": {
        "prefix": "Lambda.one.ParamPy",
        "body": [
            "lambda $1 : $1"
        ],
        "description": [
            "A lambda function is a small anonymous function.",
            "A lambda function can take any number of arguments, but can only have one expression."
        ]
    },
    "multiParamLambda": {
        "prefix": "Lambda.multi.ParamPy",
        "body": [
            "lambda $1 $2 : $3 $5 $4"
        ],
        "description": [
            "A lambda function is a small anonymous function.",
            "A lambda function can take any number of arguments, but can only have one expression."
        ]
    },
    "openFileReading": {
        "prefix": "open.File.ReadingPy",
        "body": [
            "open(\"$1\")"
        ],
        "description": "openFileReading"
    },
    "openFileOptions": {
        "prefix": "open.File.OptionsPy",
        "body": [
            "open(\"${1:filename}\", \"${2:rwax.tb}\")"
        ],
        "description": "openFileOptions"
    },
    "readLine": {
        "prefix": "readLinePy",
        "body": [
            "${1:filename}.readline()"
        ],
        "description": "Reads first line of a text if you call it once, first and second if you call it twice and so on"
    },
    "filter": {
        "prefix": "filterPy",
        "body": [
            "filter(${1:function},${2:iterable})"
        ],
        "description": "filter"
    },
    "removeFile": {
        "prefix": "remove.FilePy",
        "body": [
            "import os",
            "os.remove(\"$1\")"
        ],
        "description": "removeFile"
    },
    "currentWorkingDIrectory": {
        "prefix": "current.Working.DirPy",
        "body": [
            "import os",
            "os.getcwd()"
        ],
        "description": "currentWorkingDIrectory"
    },
    "removeFolder": {
        "prefix": "remove.FolderPy",
        "body": [
            "import os",
            "os.rmdir(\"$1\")"
        ],
        "description": "removeFolder"
    },
    "slicing": {
        "prefix": "slicingPy",
        "body": [
            "${1:list/string}[${2:start}:${3:stop}]"
        ],
        "description": "slicing"
    },
    "slicingStep": {
        "prefix": "slicing.StepPy",
        "body": [
            "${1:list/string}[${2:start}:${3:stop}:{$4:step}]"
        ],
        "description": "slicingStep"
    },
    "numpy": {
        "prefix": "import.numPy",
        "body": [
            "import numpy as np"
        ],
        "description": "numpy"
    },
    "numpyArray": {
        "prefix": "numpy.ArrayPy",
        "body": [
            "$1 = np.array([$2])"
        ],
        "description": "numpyArray"
    },
    "numpyDataType": {
        "prefix": "numpy.DataTypePy",
        "body": [
            "$1.dtype"
        ],
        "description": "numpyDataType"
    },
    "numpy.sin": {
        "prefix": "numpy.sinPy",
        "body": [
            "np.sin($1)"
        ],
        "description": "numpy.sin"
    },
    "numpy.cos": {
        "prefix": "numpy.cosPy",
        "body": [
            "np.cos($1)"
        ],
        "description": "numpy.cos"
    },
    "numpy.reshape": {
        "prefix": "numpy.reshapePy",
        "body": [
            "${1:arr}.reshape((${2:nrow}, ${3:ncol}))"
        ],
        "description": "numpy.reshape"
    },
    "numpy.arange": {
        "prefix": "numpy.arangePy",
        "body": [
            "np.arange(${1:start}, ${2:stop}, ${3:step})"
        ],
        "description": "numpy.arange"
    },
    "numpy.dot": {
        "prefix": "numpy.dotPy",
        "body": [
            "np.dot($1, $2)"
        ],
        "description": "Dot product of 2 arrays; returns sum"
    },
    "numpy.abs": {
        "prefix": "numpy.absPy",
        "body": [
            "np.abs(${1:arr})"
        ],
        "description": "Calculate the absolute value element-wise"
    },
    "numpy.rotationMatrix": {
        "prefix": "numpy.rotMatrixPy",
        "body": [
            "np.array([[math.cos(${2:angle}), -math.sin($2)],",
            "                  [math.sin($2), math.cos($2)]])",
            "$0"
        ],
        "description": "numpy.rotMatrix"
    },
    "importAll": {
        "prefix": "import.AllPy",
        "body": [
            "from $1 import *"
        ],
        "description": "importAll"
    },
    "fromImport": {
        "prefix": "from.ImportPy",
        "body": [
            "from $1 import $2"
        ],
        "description": "fromImport"
    },
    "shallowCopy": {
        "prefix": "copy.ShallowPy",
        "body": [
            "import copy",
            "$1 = copy.copy($2)"
        ],
        "description": "shallowCopy"
    },
    "deepCopy": {
        "prefix": "copy.DeepPy",
        "body": [
            "import copy",
            "$1 = copy.deepcopy($2)"
        ],
        "description": "deepCopy"
    },
    "len": {
        "prefix": "lenPy",
        "body": [
            "len($1)"
        ],
        "description": "len"
    },
    "upperCase": {
        "prefix": "upperCasePy",
        "body": [
            "$1.upper()"
        ],
        "description": "upperCase"
    },
    "lowerCase": {
        "prefix": "lowerCasePy",
        "body": [
            "$1.lower()"
        ],
        "description": "lowerCase"
    },
    "strip": {
        "prefix": "stripPy",
        "body": [
            "$1.strip()"
        ],
        "description": "strip will remove whitespaces from a string"
    },
    "split": {
        "prefix": "splitPy",
        "body": [
            "$1.split('${2:delimiter}')"
        ],
        "description": "Splits your string into a list. Your argument specifies the delimiter."
    },
    "replace": {
        "prefix": "replacePy",
        "body": [
            "$1.replace('$2', '$3')"
        ],
        "description": "replace"
    },
    "join": {
        "prefix": "joinPy",
        "body": [
            "'${1:delimeter}'.join($2)"
        ],
        "description": "join"
    },
    "abs": {
        "prefix": "absPy",
        "body": [
            "abs($1)"
        ],
        "description": "absolute value"
    },
    "round": {
        "prefix": "roundPy",
        "body": [
            "round($1)"
        ],
        "description": "round to the nearest integer"
    },
    "roundDecimals": {
        "prefix": "round.DecimalsPy",
        "body": [
            "round($1, $2)"
        ],
        "description": "roundDecimals"
    },
    "min": {
        "prefix": "minPy",
        "body": [
            "min($1,$2)"
        ],
        "description": "min"
    },
    "max": {
        "prefix": "maxPy",
        "body": [
            "max($1,$2)"
        ],
        "description": "max"
    },
    "sorted": {
        "prefix": "sortedPy",
        "body": [
            "sorted($1)"
        ],
        "description": "sorted will NOT change the original list order"
    },
    "sort": {
        "prefix": "sortPy",
        "body": [
            "$1.sort()"
        ],
        "description": "sort will CHANGE THE ORDER OF THE ORIGINAL LIST"
    },
    "sum": {
        "prefix": "sumPy",
        "body": [
            "sum($1)"
        ],
        "description": "sum"
    },
    "append": {
        "prefix": "appendPy",
        "body": [
            "$1.append($2)"
        ],
        "description": "append"
    },
    "remove": {
        "prefix": "removePy",
        "body": [
            "$1.remove($2)"
        ],
        "description": "remove"
    },
    "count": {
        "prefix": "countPy",
        "body": [
            "$1.count($2)"
        ],
        "description": "Counts number of time value appears in the list"
    },
    "clear": {
        "prefix": "clearPy",
        "body": [
            "$1.clear()"
        ],
        "description": "clear"
    },
    "keys": {
        "prefix": "keysPy",
        "body": [
            "$1.keys()"
        ],
        "description": "keys"
    },
    "values": {
        "prefix": "valuesPy",
        "body": [
            "$1.values()"
        ],
        "description": "values"
    },
    "capitalize": {
        "prefix": "capitalizePy",
        "body": [
            "$1.capitalize()"
        ],
        "description": "Capitalize will NOT change the original string"
    },
    "frozenSet": {
        "prefix": "frozenSetPy",
        "body": [
            "frozenset($1)"
        ],
        "description": "frozenSet"
    },
    "find": {
        "prefix": "findPy",
        "body": [
            "$1.find($2)"
        ],
        "description": "find substring of a string"
    },
    "pop": {
        "prefix": "popPy",
        "body": [
            "$1 = $2.pop($3)"
        ],
        "description": "pop"
    },
    "listRange": {
        "prefix": "list_RangePy",
        "body": [
            "$1 = list(range($2))"
        ],
        "description": "listRange"
    },
    "extend": {
        "prefix": "extendPy",
        "body": [
            "$1.extend($2)"
        ],
        "description": "extend"
    },
    "insert": {
        "prefix": "insertPy",
        "body": [
            "$1.insert(${2:index}, ${3:element})"
        ],
        "description": "insert"
    },
    "reverse": {
        "prefix": "reversePy",
        "body": [
            "$1.reverse()"
        ],
        "description": "reverse"
    },
    "addSet": {
        "prefix": "addSetPy",
        "body": [
            "$1.add($2)"
        ],
        "description": "addSet"
    },
    "getDict": {
        "prefix": "get.DictPy",
        "body": [
            "$1.get($2)"
        ],
        "description": "getDict"
    },
    "update": {
        "prefix": "updatePy",
        "body": [
            "${1:dictionary}.update({${2:key}:${3:value}})"
        ],
        "description": "update"
    },
    "printFormattedStrings": {
        "prefix": "print_FormatStringsPy",
        "body": [
            "print(f'$1 {$2}')"
        ],
        "description": "printFormattedStrings"
    },
    "randInt": {
        "prefix": "randIntPy",
        "body": [
            "random.randint($1,$2)"
        ],
        "description": "randInt"
    },
    "randomRandom": {
        "prefix": "randRandomPy",
        "body": [
            "random.random()"
        ],
        "description": "Generates a random number between 0 and 1"
    },
    "ifShort": {
        "prefix": "if_shortPy",
        "body": [
            "$1 = $2 if $3 else $4"
        ],
        "description": "ifShort"
    },
    "listComprehension": {
        "prefix": "list_ComprehensionPy",
        "body": [
            "$1 = [${2:variable} ${3:conditions}]"
        ],
        "description": "listComprehension"
    },
    "main": {
        "prefix": "mainPy",
        "body": [
            "if __name__ == \"__main__\":",
            "    $0"
        ],
        "description": "main"
    },
    "importSocket": {
        "prefix": "importSocketPy",
        "body": [
            "import socket as sk"
        ],
        "description": "importSocket"
    },
    "withOpen": {
        "prefix": "with.OpenPy",
        "body": [
            "with open(\"${1:file}\") as ${2:short}:",
            "    $3"
        ],
        "description": "withOpen"
    },
    "sympy": {
        "prefix": "import.symPy",
        "body": [
            "import sympy as sym"
        ],
        "description": "sympy"
    },
    "import.lambdify": {
        "prefix": "import.lambdify.Py",
        "body": [
            "from sympy.utilities.lambdify import lambdify"
        ],
        "description": "import.lambdify"
    },
    "sym.symbols": {
        "prefix": "sym.symbols.Py",
        "body": [
            "sym.symbols('$1')"
        ],
        "description": "To define symbolic variables"
    },
    "sym.diff": {
        "prefix": "sym.diff.Py",
        "body": [
            "sym.diff(${1:func}, ${2:variable}, ${3:order})"
        ],
        "description": "Derivative"
    },
    "sym.Float": {
        "prefix": "sym.Float.Py",
        "body": [
            "sym.Float(${1:num}, ${2:decimals})"
        ],
        "description": "sym.Float"
    },
    "sym.lambdify": {
        "prefix": "sym.lambdify.Py",
        "body": [
            "lambdify(${1:var}, ${2:func}, np)"
        ],
        "description": "lambdify"
    },
    "sym.exp": {
        "prefix": "sym.exp.Py",
        "body": [
            "sym.exp(${1:exponent})"
        ],
        "description": "sym.exp"
    },
    "sym.log": {
        "prefix": "sym.log.Py",
        "body": [
            "sym.log(${1:func}, ${2:base})"
        ],
        "description": "sym.log"
    },
    "sym.sqrt": {
        "prefix": "sym.sqrt.Py",
        "body": [
            "sym.sqrt(${1:func})"
        ],
        "description": "sym.sqrt"
    },
    "np.sqrt": {
        "prefix": "np.sqrt.Py",
        "body": [
            "np.sqrt(${1:arr})"
        ],
        "description": "np.sqrt"
    },
    "np.exp": {
        "prefix": "np.exp.Py",
        "body": [
            "np.exp(${1:arr})"
        ],
        "description": "np.exp"
    },
    "np.mutiply": {
        "prefix": "np.multiply.Py",
        "body": [
            "np.multiply(${1:arr1}, ${2:arr2})"
        ],
        "description": "multiplication of every element of 2 arrays; returns array"
    },
    "np.linspace": {
        "prefix": "np.linspace.Py",
        "body": [
            "np.linspace(${1:start}, ${2:stop}, num=${3:num})"
        ],
        "description": "returns num elements EVENLY SPACED"
    },
    "np.matrix": {
        "prefix": "np.matrix.Py",
        "body": [
            "np.matrix([${1:rows}, ${2:columns}])"
        ],
        "description": "np.matrix"
    },
    "np.diag": {
        "prefix": "np.diag.Py",
        "body": [
            "np.diag([${1:num1}, ${2:num2}])"
        ],
        "description": "Returns diagonal array"
    },
    "np.full": {
        "prefix": "np.full.Py",
        "body": [
            "np.full((${1:nrow}, ${2:ncol}), ${3:arr})"
        ],
        "description": "np.full"
    },
    "np.hstack": {
        "prefix": "np.hstack.Py",
        "body": [
            "np.hstack((${1:arr1}, ${2:arr2}))"
        ],
        "description": "Stack arrays horizontally"
    },
    "np.vstack": {
        "prefix": "np.vstack.Py",
        "body": [
            "np.vstack((${1:arr1}, ${2:arr2}))"
        ],
        "description": "Stack arrays vertically"
    },
    "np.zeros": {
        "prefix": "np.zeros.Py",
        "body": [
            "np.zeros((${1:nrow}, ${2:ncol}))"
        ],
        "description": [
            "Return a new float array of given shape and type, filled with zeros",
            "for int array: dtype=int at the end"
        ]
    },
    "np.eye": {
        "prefix": "np.eye.Py",
        "body": [
            "np.eye(${1:nrow}, ${2:ncol}, k=${3:whichDiag})"
        ],
        "description": [
            "Create float array with 1s on k-th diagonal and 0s elsewhere",
            "To create int array, add dtype=int at the end"
        ]
    },
    "pyplot": {
        "prefix": "import.pyplotPy",
        "body": [
            "import matplotlib.pyplot as plt"
        ],
        "description": "pyplot"
    },
    "plt.show": {
        "prefix": "plt.show.Py",
        "body": [
            "plt.show()"
        ],
        "description": "plt.show"
    },
    "plt.plot": {
        "prefix": "plt.plot.Py",
        "body": [
            "plt.plot(${1:var1}, ${2:var2})"
        ],
        "description": "plt.plot"
    },
    "plt.subplot": {
        "prefix": "plt.subplot.Py",
        "body": [
            "plt.subplot(${1:dim1}, ${2:dim2}, ${3:which})"
        ],
        "description": "Create multiple plots in one figure"
    },
    "plt.legend": {
        "prefix": "plt.legend.Py",
        "body": [
            "plt.legend([\"${1:leg1}\", \"${2:leg2}\"])"
        ],
        "description": "plt.legend"
    },
    "plt.xscale": {
        "prefix": "plt.scaleX.Py",
        "body": [
            "# value can be like: \"linear\", \"log\", ...",
            "plt.xscale(\"${1:value}\")"
        ],
        "description": "plt.xscale"
    },
    "plt.yscale": {
        "prefix": "plt.scaleY.Py",
        "body": [
            "# value can be like: \"linear\", \"log\", ...",
            "plt.yscale(\"${2:value}\")"
        ],
        "description": "plt.yscale"
    },
    "plt.xyscale": {
        "prefix": "plt.scaleXY.Py",
        "body": [
            "# value can be like: \"linear\", \"log\", ...",
            "plt.xscale(\"${1:value}\")",
            "plt.yscale(\"${2:value}\")"
        ],
        "description": "plt.xyscale"
    },
    "plt.xlabel": {
        "prefix": "plt.labelX.Py",
        "body": [
            "plt.xlabel(\"$1\")"
        ],
        "description": "plt.xlabel"
    },
    "plt.ylabel": {
        "prefix": "plt.labelY.Py",
        "body": [
            "plt.ylabel(\"$1\")"
        ],
        "description": "plt.ylabel"
    },
    "plt.xylabel": {
        "prefix": "plt.labelXY.Py",
        "body": [
            "plt.xlabel(\"$1\")",
            "plt.ylabel(\"$2\")"
        ],
        "description": "plt.xylabel"
    },
    "plt.title": {
        "prefix": "plt.title.Py",
        "body": [
            "plt.title(\"${1:TITLE HERE}\")"
        ],
        "description": "plt.title"
    },
    "plt.grid": {
        "prefix": "plt.grid.Py",
        "body": [
            "plt.grid()"
        ],
        "description": "Show grid"
    },
    "plt.xticks": {
        "prefix": "plt.ticksX.Py",
        "body": [
            "plt.xticks(np.arange(${1:start}, ${2:stop}, ${3:step}))"
        ],
        "description": "plt.xticks"
    },
    "plt.yticks": {
        "prefix": "plt.ticksY.Py",
        "body": [
            "plt.yticks(np.arange(${1:start}, ${2:stop}, ${3:step}))"
        ],
        "description": "plt.yticks"
    },
    "plt.xyticks": {
        "prefix": "plt.ticksXY.Py",
        "body": [
            "plt.xticks(np.arange(${1:startX}, ${2:stopX}, ${3:stepX}))",
            "plt.yticks(np.arange(${4:startY}, ${5:stopY}, ${6:stepY}))"
        ],
        "description": "plt.xyticks"
    },
    "plt.xlim": {
        "prefix": "plt.limX.Py",
        "body": [
            "plt.xlim(${1:start}, ${2:stop})"
        ],
        "description": "plt.xlim; Limits plot to range in X axis"
    },
    "plt.ylim": {
        "prefix": "plt.limY.Py",
        "body": [
            "plt.ylim(${1:start}, ${2:stop})"
        ],
        "description": "plt.xlim; Limits plot to range in Y axis"
    },
    "plt.xylim": {
        "prefix": "plt.limXY.Py",
        "body": [
            "plt.xlim(${1:startX}, ${2:stopX})",
            "plt.ylim(${3:startY}, ${4:stopY})"
        ],
        "description": "plt.xylim"
    },
    "scipy.linalg": {
        "prefix": "import.scipy.linalgPy",
        "body": [
            "import scipy.linalg as spl"
        ],
        "description": "scipy.linalg"
    },
    "sympy.solvers.solve": {
        "prefix": "sympy.solvers.solvePy",
        "body": [
            "from sympy.solvers import solve",
            "x = symbols('x')",
            "solve(${1:eq}, x)"
        ],
        "description": "solve; all equations are equal to 0"
    },
    "spl.solve": {
        "prefix": "spl.solvePy",
        "body": [
            "import scipy.linalg as spl",
            "spl.solve(${1:arr1}, ${2:arr2})"
        ],
        "description": "spl.solve"
    },
    "spl.hilbert": {
        "prefix": "spl.hilbertPy",
        "body": [
            "import scipy.linalg as spl",
            "spl.hilbert(${1:n})"
        ],
        "description": "Create a Hilbert matrix of order n"
    },
    "np.linalg": {
        "prefix": "import.np.linalgPy",
        "body": [
            "import numpy.linalg as npl"
        ],
        "description": "np.linalg"
    },
    "npl.norm": {
        "prefix": "npl.normPy",
        "body": [
            "import numpy.linalg as npl",
            "# ord can be none, inf, -inf, 0, 1, -1, 2, -2, ...",
            "npl.norm(${1:arr}, np.${2:ord})"
        ],
        "description": "matrix or vector norm"
    },
    "npl.cond": {
        "prefix": "npl.condPy",
        "body": [
            "import numpy.linalg as npl",
            "# ord can be none, inf, -inf, 1, -1, 2, -2, ...",
            "npl.cond(${1:arr}, np.${2:ord})"
        ],
        "description": "Compute the condition number of a matrix"
    },
    "switchDict": {
        "prefix": "switch.DictPy",
        "body": [
            "switch = {",
            "    \"1\": ${1:func},",
            "    \"2\": ${2:func}",
            "}",
            ""
        ],
        "description": "switchDict"
    },
    "time.perf_counter": {
        "prefix": "perf_counter.Py",
        "body": [
            "import time",
            "start_time = time.perf_counter()",
            "# ...INSERT CODE HERE...",
            "end_time = time.perf_counter()"
        ],
        "description": "perf_counter.Py"
    },
    "spacing.definition": {
        "prefix": "Definition.spacing.Py",
        "body": [
            "p = 0",
            "t = 53",
            "# eps = 2**(-52)",
            "spacing = 2**(p+1-t)   # spacing sul segmento [2^p, 2^(p+1)]=[1,2]"
        ],
        "description": "definition.spacing.Py"
    },
    "spacing": {
        "prefix": "spacing.Py",
        "body": [
            "np.spacing(${1:num})"
        ],
        "description": "Return the distance between num and the nearest adjacent number"
    },
    "roundoff": {
        "prefix": "roundoff.Py",
        "body": [
            "# roundoff unit",
            "u = np.spacing(1)/2"
        ],
        "description": "1/2 * spacing(1)"
    },
    "withOpenCSV": {
        "prefix": "with.Open.CSVPy",
        "body": [
            "import csv",
            "import os",
            "with open(os.getcwd() + \"${1:file}\", '${2:opt}', encoding='utf-8-sig') as ${3:short}:",
            "   \"\"\"",
            "   reader = csv.DictReader($3)",
            "   header = next(reader)",
            "   print(header)",
            "   for line in reader:",
            "   print(line)",
            "   \"\"\""
        ],
        "description": "withOpenCSV"
    },
    "metodo di Bisezione": {
        "prefix": "bisezionePy",
        "body": [
            "def bisezione(fname, a, b, tolx):",
            "    eps = np.spacing(1)",
            "    fa = fname(a)",
            "    fb = fname(b)",
            "    if sign(fa) == sign(fb):",
            "        print(\"Metodo non applicabile. L'intervallo [a,b] non è corretto\")",
            "        return [], 0, []",
            "    else:",
            "        maxit = int(math.ceil(math.log((b - a) / tolx) / math.log(2)))",
            "        print(f\"numero di passi necessari = {maxit}\\n\")",
            "        xk = []",
            "        it = 0",
            "",
            "        while it < maxit \\",
            "                and abs(b - a) >= tolx + eps * max(abs(a), abs(b)):",
            "         ",
            "            c = a + (b - a) * 0.5",
            "            xk.append(c)",
            "            fxk = fname(c)",
            "",
            "            if fxk == 0:",
            "                break",
            "            elif sign(fxk) == sign(fa):",
            "                a = c",
            "                fa = fxk",
            "            elif sign(fxk) == sign(fb):",
            "                b = c",
            "                fb = fxk",
            "",
            "            it += 1",
            "",
            "        x = c",
            "",
            "    return x, it, xk"
        ],
        "description": "metodo di bisezione"
    },
    "copysign": {
        "prefix": "signPy",
        "body": [
            "def sign(x):",
            "    return math.copysign(1, x)"
        ],
        "description": "copysign"
    },
    "metodo regula falsi": {
        "prefix": "regulaFalsiPy",
        "body": [
            "def regula_falsi(fname, a, b, tolx, nmax):",
            "    eps = np.spacing(1)",
            "    xk = []",
            "",
            "    fa = fname(a)",
            "    fb = fname(b)",
            "",
            "    if sign(fa) == sign(fb):",
            "        print(\"Metodo non applicabile. L'intervallo [a,b] non è corretto\")",
            "        return [], 0, []",
            "    else:",
            "        it = 0",
            "        fxk = fname(a)",
            "",
            "        while it < nmax \\",
            "                and abs(b - a) >= tolx + eps * max(abs(a), abs(b)) \\",
            "                and abs(fxk) >= tolx:",
            "",
            "            x1 = a - fa * (b - a) / (fb - fa)",
            "            xk.append(x1)",
            "            fxk = fname(x1)",
            "",
            "            if fxk == 0:",
            "                break",
            "            elif sign(fxk) == sign(fa):",
            "                a = x1",
            "                fa = fxk",
            "            elif sign(fxk) == sign(fb):",
            "                b = x1",
            "                fb = fxk",
            "            it += 1",
            "",
            "        if it == nmax:",
            "            print(\"regula_falsi: raggiunto il numero massimo di iterazioni\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "metodo regula falsi"
    },
    "metodo delle corde": {
        "prefix": "cordePy",
        "body": [
            "def corde(fname, fpname, x0, tolx, tolf, nmax):",
            "    xk = []",
            "    m = fpname(x0)",
            "    fx0 = fname(x0)",
            "",
            "    d = fx0 / m",
            "    x1 = x0 - d",
            "    fx1 = fname(x1)",
            "",
            "    xk.append(x1)",
            "    it = 1",
            "",
            "    while it < nmax \\",
            "            and abs(fx1) >= tolf \\",
            "            and abs(d) >= tolx * abs(x1):",
            "",
            "        x0 = x1",
            "        fx0 = fname(x0)",
            "        d = fx0 / m",
            "       ",
            "        x1 = x0 - d",
            "        fx1 = fname(x1)",
            "        it = it + 1",
            "        xk.append(x1)",
            "",
            "    if it == nmax:",
            "        print(\"raggiunto il numero massimo di iterazioni\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "metodo delle corde"
    },
    "metodo delle secanti": {
        "prefix": "secantiPy",
        "body": [
            "def secanti(fname, xm1, x0, tolx, tolf, nmax):",
            "    xk = []",
            "    fxm1 = fname(xm1)",
            "    fx0 = fname(x0)",
            "",
            "    d = fx0 * (x0 - xm1) / (fx0 - fxm1)",
            "    x1 = x0 - d",
            "    xk.append(x1)",
            "    fx1 = fname(x1)",
            "    it = 1",
            "",
            "    while it < nmax and abs(fx1) >= tolf and abs(d) >= tolx * abs(x1):",
            "",
            "        xm1 = x0",
            "        x0 = x1",
            "        fxm1 = fname(xm1)",
            "        fx0 = fname(x0)",
            "",
            "        d = fx0 * (x0 - xm1) / (fx0 - fxm1)",
            "        x1 = x0 - d",
            "        fx1 = fname(x1)",
            "        xk.append(x1)",
            "        it = it + 1",
            "",
            "    if it == nmax:",
            "        print(\"secanti: raggiunto il numero massimo di iterazioni\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "metodo delle corde"
    },
    "metodo di newton": {
        "prefix": "newtonPy",
        "body": [
            "def newton(fname, fpname, x0, tolx, tolf, nmax):",
            "    xk = []",
            "    fx0 = fname(x0)",
            "    dfx0 = fpname(x0)",
            "",
            "    if abs(dfx0) > np.spacing(1):",
            "        d = fx0 / dfx0",
            "        x1 = x0 - d",
            "        fx1 = fname(x1)",
            "        xk.append(x1)",
            "        it = 0",
            "",
            "    else:",
            "        print(\"newton: derivata nulla in x0\\n\")",
            "        return [], 0, []",
            "",
            "    it = 1",
            "    while it < nmax \\",
            "            and abs(fx1) >= tolf \\",
            "            and abs(d) >= tolx * abs(x1):",
            "",
            "        x0 = x1",
            "        fx0 = fname(x0)",
            "        dfx0 = fpname(x0)",
            "",
            "        if abs(dfx0) > np.spacing(1):",
            "            d = fx0 / dfx0",
            "            x1 = x0 - d",
            "            fx1 = fname(x1)",
            "            xk.append(x1)",
            "            it = it + 1",
            "        else:",
            "            print(\"newton: derivata nulla in x0\\n\")",
            "            return x1, it, xk",
            "",
            "    if it == nmax:",
            "        print(\"newton: raggiunto il numero massimo di iterazioni\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "metodo di newton"
    },
    "stima ordine": {
        "prefix": "stima_ordinePy",
        "body": [
            "def stima_ordine(xk, iterazioni):",
            "    p = []",
            "",
            "    for k in range(iterazioni - 3):",
            "        p.append(np.log(abs(xk[k + 2] - xk[k + 3]) / abs(xk[k + 1] - xk[k + 2])) /",
            "                 np.log(abs(xk[k + 1] - xk[k + 2]) / abs(xk[k] - xk[k + 1])))",
            "",
            "    ordine = p[-1]",
            "    return ordine"
        ],
        "description": "stima ordine"
    },
    "newton modificato": {
        "prefix": "newton_modPy",
        "body": [
            "def newton_mod(fname, fpname, x0, m, tolx, tolf, nmax):",
            "    eps = np.spacing(1)",
            "    xk = []",
            "    # xk.append(x0)",
            "    fx0 = fname(x0)",
            "    dfx0 = fpname(x0)",
            "",
            "    if abs(dfx0) > eps:",
            "        d = fx0 / dfx0",
            "        x1 = x0 - m * d",
            "        fx1 = fname(x1)",
            "        xk.append(x1)",
            "        it = 0",
            "",
            "    else:",
            "        print(\"newton: derivata nulla in x0\\n\")",
            "        return [], 0, []",
            "",
            "    it = 1",
            "    while it < nmax \\",
            "            and abs(fx1) >= tolf \\",
            "            and abs(d) >= tolx * abs(x1):",
            "",
            "        x0 = x1",
            "        fx0 = fname(x0)",
            "        dfx0 = fpname(x0)",
            "",
            "        if abs(dfx0) > eps:",
            "            d = fx0 / dfx0",
            "            x1 = x0 - m * d",
            "            fx1 = fname(x1)",
            "            xk.append(x1)",
            "            it = it + 1",
            "        else:",
            "            print(\"newton_mod: derivata nulla\\n\")",
            "            return x1, it, xk",
            "",
            "    if it == nmax:",
            "        print(\"newton_mod: raggiunto il numero massimo di iterazioni\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "newton modificato"
    },
    "iterazione": {
        "prefix": "iterazionePy",
        "body": [
            "def iterazione(gname, x0, tolx, nmax):",
            "    xk = []",
            "    xk.append(x0)",
            "    x1 = gname(x0)",
            "",
            "    d = x1 - x0",
            "    xk.append(x1)",
            "    it = 1",
            "",
            "    while it < nmax \\",
            "            and abs(d) >= tolx * abs(x1):",
            "        x0 = x1",
            "        x1 = gname(x0)",
            "        d = x1 - x0",
            "        it = it + 1",
            "        xk.append(x1)",
            "",
            "    if it == nmax:",
            "        print(\"raggiunto numero massimo di iterazioni\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "iterazione"
    },
    "Lsolve": {
        "prefix": "Lsolve_Py",
        "body": [
            "def Lsolve(L, b):",
            "    m, n = L.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata. Errore!!\")",
            "        flag = 1",
            "        x = []",
            "        return x, flag",
            "",
            "    ",
            "    if np.all(np.diag(L)) != True:",
            "        print(\"elemento diagonale nullo: la matrice è triangolare inferiore\")",
            "        x = []",
            "        flag = 1",
            "        return x, flag",
            "    ",
            "    x = np.zeros((n, 1))",
            "",
            "    for i in range(n):",
            "        prod = np.dot(L[i, :i], x[:i])",
            "        x[i] = (b[i] - prod) / L[i, i]",
            "",
            "    return x, flag"
        ],
        "description": "Lsolve"
    },
    "Usolve": {
        "prefix": "Usolve_Py",
        "body": [
            "def Usolve(U, b):",
            "    m, n = U.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata. Errore!!\")",
            "        flag = 1",
            "        x = []",
            "        return x, flag",
            "",
            "    ",
            "    if np.all(np.diag(U)) != True:",
            "        print(\"elemento diagonale nullo: la matrice è triangolare superiore\")",
            "        x = []",
            "        flag = 1",
            "        return x, flag",
            "",
            "    x = np.zeros((n, 1))",
            "",
            "    for i in range(n - 1, -1, -1):",
            "        prod = np.dot(U[i, i + 1:n], x[i + 1:n])",
            "        x[i] = (b[i] - prod) / U[i, i]",
            "",
            "    return x, flag"
        ],
        "description": "Usolve"
    },
    "LUsolve": {
        "prefix": "LUsolve_Py",
        "body": [
            "def LUsolve(L, U, P, b):",
            "    Pb = np.dot(P, b)",
            "    y, flag = Lsolve(L, Pb)",
            "",
            "    if flag == 0:",
            "        x, flag = Usolve(U, y)",
            "    else:",
            "        return [], flag",
            "",
            "    return x, flag"
        ],
        "description": "LUsolve"
    },
    "LU_no_pivot": {
        "prefix": "LU_no_pivotPy",
        "body": [
            "def LU_nopivot(A):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        L, U, P, flag = [], [], [], 1",
            "        return P, L, U, flag",
            "",
            "    P = np.eye(n)",
            "    U = A.copy()",
            " ",
            "    for k in range(n - 1):",
            "        if U[k, k] == 0:",
            "            print(\"elemento diagonale nullo\")",
            "            L, U, P, flag = [], [], [], 1",
            "            return P, L, U, flag",
            "",
            "        U[k + 1:n, k] = U[k + 1:n, k] / U[k, k]",
            "        U[k + 1:n, k + 1:n] = U[k + 1:n, k + 1:n] - \\",
            "            np.outer(U[k + 1:n, k], U[k, k + 1:n])",
            "",
            "    L = np.tril(U, -1) + np.eye(n)",
            "    U = np.triu(U)",
            "",
            "    return P, L, U, flag"
        ],
        "description": "LU_no_pivot"
    },
    "LU_no_pivot_vect": {
        "prefix": "LU_no_pivot_vectPy",
        "body": [
            "def LU_nopivot_vect(A):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        L, U, P, flag = [], [], [], 1",
            "        return P, L, U, flag",
            "",
            "    P = np.eye(n)",
            "    U = A.copy()",
            " ",
            "    for k in range(n - 1):",
            "        if U[k, k] == 0:",
            "            print(\"elemento diagonale nullo2)",
            "            L, U, P, flag = [], [], [], 1",
            "            return P, L, U, flag",
            "",
            "        for i in range(k + 1, n):",
            "            U[i, k] = U[i, k] / U[k, k]",
            "            U[i, k + 1:n] = U[i, k + 1:n] - U[i, k] * \\",
            "                U[k, k + 1:n] ",
            "",
            "    L = np.tril(U, -1) + np.eye(n)",
            "    U = np.triu(U)",
            "",
            "    return P, L, U, flag"
        ],
        "description": "LU_no_pivot_vect"
    },
    "LU_no_pivot_base": {
        "prefix": "LU_no_pivot_basePy",
        "body": [
            "def LU_nopivot_base(A):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        L, U, P, flag = [], [], [], 1",
            "        return P, L, U, flag",
            "",
            "    P = np.eye(n)",
            "    U = A.copy()",
            "",
            "    for k in range(n - 1):",
            "        if U[k, k] == 0:",
            "            print(\"elemento diagonale nullo\")",
            "            L, U, P, flag = [], [], [], 1",
            "            return P, L, U, flag",
            "",
            "        for i in range(k + 1, n):",
            "            U[i, k] = U[i, k] / U[k, k]",
            "            for j in range(k + 1, n):",
            "                U[i, j] = U[i, j] - U[i, k] * U[k, j]",
            "",
            "    L = np.tril(U, -1) + np.eye(n)",
            "    U = np.triu(U)",
            "",
            "    return P, L, U, flag"
        ],
        "description": "LU_no_pivot_base"
    },
    "swapRows": {
        "prefix": "swapRowsPy",
        "body": [
            "def swapRows(A, k, p):",
            "    A[[k, p], :] = A[[p, k], :]"
        ],
        "description": "swapRows"
    },
    "LU_pivot": {
        "prefix": "LU_pivot_Py",
        "body": [
            "def LU_pivot(A):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        L, U, P, flag = [], [], [], 1",
            "        return P, L, U, flag",
            "",
            "    P = np.eye(n)",
            "    U = A.copy()",
            "",
            "    for k in range(n - 1):",
            "        p = np.argmax(abs(U[k:n, k])) + k",
            "        if p != k:",
            "            swapRows(P, k, p)",
            "            swapRows(U, k, p)",
            "",
            "        U[k + 1:n, k] = U[k + 1:n, k] / U[k, k]",
            "        U[k + 1:n, k + 1:n] = U[k + 1:n, k + 1:n] - \\",
            "            np.outer(U[k + 1:n, k], U[k, k + 1:n])",
            "",
            "    L = np.tril(U, -1) + np.eye(n)",
            "    U = np.triu(U)",
            "",
            "    return P, L, U, flag"
        ],
        "description": "LU_pivot"
    },
    "solve_nsis": {
        "prefix": "solve_nsis_Py",
        "body": [
            "def solve_nsis(A, B):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        return",
            "",
            "    Y = np.zeros((n, n))",
            "    X = np.zeros((n, n))",
            "    P, L, U, flag = LU_nopivot(A)",
            "",
            "    if flag == 0:",
            "        for i in range(n):",
            "            y, flag = Lsolve(L, np.dot(P, B[:, i]))",
            "            Y[:, i] = y.squeeze(1)",
            "",
            "            x, flag = Usolve(U, Y[:, i])",
            "            X[:, i] = x.squeeze(1)",
            "    else:",
            "        print(\"elemento diagonale nullo\")",
            "        X = []",
            "    return X"
        ],
        "description": "solve_nsis"
    },
    "poly_lagrange": {
        "prefix": "poly_lagrange_Py",
        "body": [
            "def polynomial_lagrange(xnodi, k):",
            "    xzeri = np.zeros_like(xnodi)",
            "    n = xnodi.size",
            "    if k == 0:",
            "        xzeri = xnodi[1:n]",
            "    else:",
            "        xzeri = np.append(xnodi[0:k], xnodi[k + 1:n])",
            "",
            "    num = np.poly(xzeri)",
            "    den = np.polyval(num, xnodi[k])",
            "",
            "    pol = num / den",
            "",
            "    return pol"
        ],
        "description": "poly_lagrange"
    },
    "interpolation_lagrange": {
        "prefix": "interpolation_lagrange_Py",
        "body": [
            "def InterpolationLagrange(x, f, xx):",
            "    n = x.size",
            "    m = xx.size",
            "    L = np.zeros((n, m))",
            "",
            "    for k in range(n):",
            "        pol = polynomial_lagrange(x, k)",
            "        L[k, :] = np.polyval(pol, xx)",
            "",
            "    return np.dot(f, L)"
        ],
        "description": "interpolation_lagrange"
    },
    "composizione trapezio": {
        "prefix": "trapezio_comp_Py",
        "body": [
            "def TrapezoidComp(fname, a, b, n):",
            "    h = (b - a) / n",
            "    nodi = np.arange(a, b + h, h)",
            "    f = fname(nodi)",
            "    I = (f[0] + 2 * np.sum(f[1:n]) + f[n]) * h / 2",
            "",
            "    return I"
        ],
        "description": "composizione trapezio"
    },
    "composizione simpson": {
        "prefix": "simpson_comp_Py",
        "body": [
            "def SimpsonComp(fname, a, b, n):",
            "    h = (b - a) / (2 * n)",
            "    nodi = np.arange(a, b + h, h)",
            "    f = fname(nodi)",
            "    I = (f[0] + 2 * np.sum(f[2:2 * n:2]) + 4 *",
            "         np.sum(f[1:2 * n:2]) + f[2 * n]) * h / 3",
            "",
            "    return I"
        ],
        "description": "composizione simpson"
    },
    "tolleranza trapezio": {
        "prefix": "trapezio_toll_Py",
        "body": [
            "def trapezoid_toll(fun, a, b, tol):",
            "    Nmax = 2048",
            "    err = 1",
            "",
            "    N = 1",
            "    IN = TrapezoidComp(fun, a, b, N)",
            "",
            "    while N <= Nmax and err > tol:",
            "        N = 2 * N",
            "        I2N = TrapezoidComp(fun, a, b, N)",
            "        err = abs(IN - I2N) / 3",
            "        IN = I2N",
            "",
            "    if N > Nmax:",
            "        print(\"raggiunto nmax di intervalli con traptoll\")",
            "        N = 0",
            "        IN = []",
            "",
            "    return IN, N"
        ],
        "description": "tolleranza trapezio"
    },
    "tolleranza simpson": {
        "prefix": "simpson_toll_Py",
        "body": [
            "def simpson_toll(fun, a, b, tol):",
            "    Nmax = 2048",
            "    err = 1",
            "",
            "    N = 1",
            "    IN = SimpsonComp(fun, a, b, N)",
            "",
            "    while N <= Nmax and err > tol:",
            "        N = 2 * N",
            "        I2N = SimpsonComp(fun, a, b, N)",
            "        err = abs(IN - I2N) / 15",
            "        IN = I2N",
            "",
            "    if N > Nmax:",
            "        print(\"raggiunto nmax di intervalli con traptoll\")",
            "        N = 0",
            "        IN = []",
            "",
            "    return IN, N"
        ],
        "description": "tolleranza simpson"
    },
    "metodo QR": {
        "prefix": "QR_Py",
        "body": [
            "def metodoQR(x, y, n):",
            "    H = np.vander(x, n + 1)",
            "    Q, R = spl.qr(H)",
            "    y1 = np.dot(Q.T, y)",
            "    a, flag = Usolve(R[0:n + 1, :], y1[0:n + 1])",
            "",
            "    return a"
        ],
        "description": "metodo QR"
    }
}