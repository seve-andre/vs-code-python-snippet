{
    "for": {
        "prefix": "for.Py",
        "body": [
            "for $1 in $2:",
            "    $3"
        ],
        "description": "for"
    },
    "forRange": {
        "prefix": "for.RangePy",
        "body": [
            "for $1 in range($2):",
            "    $3"
        ],
        "description": "for with range(0, n-1)"
    },
    "while": {
        "prefix": "whilePy",
        "body": [
            "while $1:",
            "    $2"
        ],
        "description": "while"
    },
    "if": {
        "prefix": "if.Py",
        "body": [
            "if $1:",
            "    $2"
        ],
        "description": "if"
    },
    "ifElse": {
        "prefix": "if_ElsePy",
        "body": [
            "if $1:",
            "    $2",
            "else:",
            "    $3"
        ],
        "description": "ifElse"
    },
    "elif": {
        "prefix": "elifPy",
        "body": [
            "if $1:",
            "    $2",
            "elif $3:",
            "    $4"
        ],
        "description": "elif"
    },
    "emptyList": {
        "prefix": "list_empty.Py",
        "body": [
            "${1:list_name} = []"
        ],
        "description": "emptyList"
    },
    "list": {
        "prefix": "list.Py",
        "body": [
            "${1:list_name} = [$2]"
        ],
        "description": [
            "List items are ordered, changeable and allow duplicate values",
            "List items are indexed, the first item has index [0], the second item has index [1] etc."
        ]
    },
    "dict": {
        "prefix": "dictPy",
        "body": [
            "${1:dictionary_name} = {",
            "    $2: $3,",
            "    $4: $5",
            "}"
        ],
        "description": [
            "A dictionary is a collection which is ordered (As of Python version 3.7, dictionaries are ordered.",
            "In Python 3.6 and earlier, dictionaries are unordered), changeable and does not allow duplicates.",
            "Dictionary items are presented in key:value pairs, and can be referred to by using the key name."
        ]
    },
    "print": {
        "prefix": "print.Py",
        "body": [
            "print($1)"
        ],
        "description": "print"
    },
    "printString": {
        "prefix": "print_StrPy",
        "body": [
            "print(\"$1\")"
        ],
        "description": "printString"
    },
    "printSep": {
        "prefix": "print_SepPy",
        "body": [
            "print($1, $2, sep=\"$3\")"
        ],
        "description": "printSep"
    },
    "printEnd": {
        "prefix": "print_EndPy",
        "body": [
            "print($1, end=\"$2\")"
        ],
        "description": "printEnd"
    },
    "def": {
        "prefix": "defPy",
        "body": [
            "def ${1:function_name}($2):",
            "    $3 "
        ],
        "description": "def"
    },
    "castInt": {
        "prefix": "cast.IntPy",
        "body": [
            "int($1)"
        ],
        "description": "castInt"
    },
    "castFloat": {
        "prefix": "castFloatPy",
        "body": [
            "float($1)"
        ],
        "description": "castFloat"
    },
    "castStr": {
        "prefix": "cast.StrPy",
        "body": [
            "str($1)"
        ],
        "description": "castStr"
    },
    "castList": {
        "prefix": "cast_list.Py",
        "body": [
            "list($1)"
        ],
        "description": "castList"
    },
    "tuple": {
        "prefix": "tuplePy",
        "body": [
            "${1:tuplename} = ($2, $3)"
        ],
        "description": [
            "A tuple is a collection which is ordered, unchangeable and allow duplicate values",
            "Tuple items are indexed, the first item has index [0], the second item has index [1] etc."
        ]
    },
    "set": {
        "prefix": "setPy",
        "body": [
            "${1:setname} = {$2, $3}"
        ],
        "description": "Set items are unordered (so you cannot be sure in which order the items will appear), unchangeable and do not allow duplicate values."
    },
    "class": {
        "prefix": "classPy",
        "body": [
            "class ${1:ClassName}:",
            "    $2"
        ],
        "description": "class"
    },
    "tryExceptEmpty": {
        "prefix": "try.Except.EmptyPy",
        "body": [
            "try:",
            "    $1",
            "except:",
            "    $2"
        ],
        "description": "tryExceptEmpty"
    },
    "tryExcept": {
        "prefix": "try.ExceptPy",
        "body": [
            "try:",
            "    $1",
            "except $2:",
            "    $3"
        ],
        "description": "tryExcept"
    },
    "input": {
        "prefix": "inputPy",
        "body": [
            "input($1)"
        ],
        "description": "input"
    },
    "multiPoundComment": {
        "prefix": "comment.Multi.PoundPy",
        "body": [
            "# $1",
            "# $2"
        ],
        "description": "multiPoundComment"
    },
    "multiLineComment": {
        "prefix": "comment.Multi.LinePy",
        "body": [
            "\"\"\"",
            "$1",
            "$2",
            "\"\"\""
        ],
        "description": "multiLineComment"
    },
    "type": {
        "prefix": "typePy",
        "body": [
            "type($1)"
        ],
        "description": "You can get the data type of a variable with the type() function."
    },
    "oneParamLambda": {
        "prefix": "Lambda.one.ParamPy",
        "body": [
            "lambda $1 : $1"
        ],
        "description": [
            "A lambda function is a small anonymous function.",
            "A lambda function can take any number of arguments, but can only have one expression."
        ]
    },
    "multiParamLambda": {
        "prefix": "Lambda.multi.ParamPy",
        "body": [
            "lambda $1 $2 : $3 $5 $4"
        ],
        "description": [
            "A lambda function is a small anonymous function.",
            "A lambda function can take any number of arguments, but can only have one expression."
        ]
    },
    "openFileReading": {
        "prefix": "open.File.ReadingPy",
        "body": [
            "open(\"$1\")"
        ],
        "description": "openFileReading"
    },
    "openFileOptions": {
        "prefix": "open.File.OptionsPy",
        "body": [
            "open(\"${1:filename}\", \"${2:rwax.tb}\")"
        ],
        "description": "openFileOptions"
    },
    "readLine": {
        "prefix": "readLinePy",
        "body": [
            "${1:filename}.readline()"
        ],
        "description": "Reads first line of a text if you call it once, first and second if you call it twice and so on"
    },
    "filter": {
        "prefix": "filterPy",
        "body": [
            "filter(${1:function},${2:iterable})"
        ],
        "description": "filter"
    },
    "removeFile": {
        "prefix": "remove.FilePy",
        "body": [
            "import os",
            "os.remove(\"$1\")"
        ],
        "description": "removeFile"
    },
    "currentWorkingDIrectory": {
        "prefix": "current.Working.DirPy",
        "body": [
            "import os",
            "os.getcwd()"
        ],
        "description": "currentWorkingDIrectory"
    },
    "removeFolder": {
        "prefix": "remove.FolderPy",
        "body": [
            "import os",
            "os.rmdir(\"$1\")"
        ],
        "description": "removeFolder"
    },
    "slicing": {
        "prefix": "slicingPy",
        "body": [
            "${1:list/string}[${2:start}:${3:stop(excl.)}]"
        ],
        "description": "slicing"
    },
    "slicingStep": {
        "prefix": "slicing.StepPy",
        "body": [
            "${1:list/string}[${2:start}:${3:stop(excl.)}:${4:step}]"
        ],
        "description": "slicingStep"
    },
    "numpy": {
        "prefix": "import.numPy",
        "body": [
            "import numpy as np"
        ],
        "description": "numpy"
    },
    "numpyArray": {
        "prefix": "numpy.ArrayPy",
        "body": [
            "$1 = np.array([$2])"
        ],
        "description": "numpyArray"
    },
    "numpyDataType": {
        "prefix": "numpy.DataTypePy",
        "body": [
            "$1.dtype"
        ],
        "description": "numpyDataType"
    },
    "numpy.sin": {
        "prefix": "numpy.sinPy",
        "body": [
            "np.sin($1)"
        ],
        "description": "numpy.sin"
    },
    "numpy.cos": {
        "prefix": "numpy.cosPy",
        "body": [
            "np.cos($1)"
        ],
        "description": "numpy.cos"
    },
    "numpy.reshape": {
        "prefix": "numpy.reshapePy",
        "body": [
            "${1:arr}.reshape((${2:nrow}, ${3:ncol}))"
        ],
        "description": "numpy.reshape"
    },
    "numpy.arange": {
        "prefix": "numpy.arangePy",
        "body": [
            "np.arange(${1:start}, ${2:stop}, ${3:step})"
        ],
        "description": "numpy.arange"
    },
    "numpy.dot": {
        "prefix": "numpy.dotPy",
        "body": [
            "np.dot($1, $2)"
        ],
        "description": "Dot product of 2 arrays; returns sum"
    },
    "numpy.abs": {
        "prefix": "numpy.absPy",
        "body": [
            "np.abs(${1:arr})"
        ],
        "description": "Calculate the absolute value element-wise"
    },
    "numpy.rotationMatrix": {
        "prefix": "numpy.rotMatrixPy",
        "body": [
            "np.array([[math.cos(${2:angle}), -math.sin($2)],",
            "                  [math.sin($2), math.cos($2)]])",
            "$0"
        ],
        "description": "numpy.rotMatrix"
    },
    "importAll": {
        "prefix": "import.AllPy",
        "body": [
            "from $1 import *"
        ],
        "description": "importAll"
    },
    "fromImport": {
        "prefix": "from.ImportPy",
        "body": [
            "from $1 import $2"
        ],
        "description": "fromImport"
    },
    "shallowCopy": {
        "prefix": "copy.ShallowPy",
        "body": [
            "import copy",
            "$1 = copy.copy($2)"
        ],
        "description": "shallowCopy"
    },
    "deepCopy": {
        "prefix": "copy.DeepPy",
        "body": [
            "import copy",
            "$1 = copy.deepcopy($2)"
        ],
        "description": "deepCopy"
    },
    "len": {
        "prefix": "len.str.Py",
        "body": [
            "len($1)"
        ],
        "description": "len"
    },
    "upperCase": {
        "prefix": "upperCase.str.Py",
        "body": [
            "${1:string}.upper()"
        ],
        "description": "upperCase"
    },
    "lowerCase": {
        "prefix": "lowerCase.str.Py",
        "body": [
            "${1:string}.lower()"
        ],
        "description": "lowerCase"
    },
    "strip": {
        "prefix": "strip.str.Py",
        "body": [
            "${1:string}.strip()"
        ],
        "description": "strip will remove whitespaces from a string"
    },
    "split": {
        "prefix": "split.string.Py",
        "body": [
            "${1:string}.split('${2:separator}')"
        ],
        "description": "Splits your string into a list. Your argument specifies the separator."
    },
    "replace": {
        "prefix": "replace.str.Py",
        "body": [
            "${1:string}.replace('$2', '$3')"
        ],
        "description": "replace"
    },
    "join": {
        "prefix": "joinPy",
        "body": [
            "'${1:separator}'.join(${2:string})"
        ],
        "description": "join"
    },
    "abs": {
        "prefix": "absPy",
        "body": [
            "abs(${1:number})"
        ],
        "description": "absolute value"
    },
    "round": {
        "prefix": "round.Py",
        "body": [
            "round(${1:number})"
        ],
        "description": "round to the nearest integer"
    },
    "roundDecimals": {
        "prefix": "round_DecimalsPy",
        "body": [
            "round(${1:number}, ${2:digits})"
        ],
        "description": "roundDecimals"
    },
    "min.param": {
        "prefix": "min_param.Py",
        "body": [
            "min($1,$2)"
        ],
        "description": "min: in case of a string, it returns the string that comes first in alphabetical order"
    },
    "min": {
        "prefix": "min.Py",
        "body": [
            "min()"
        ],
        "description": "min: in case of a string, it returns the string that comes first in alphabetical order"
    },
    "max.param": {
        "prefix": "max_param.Py",
        "body": [
            "max($1,$2)"
        ],
        "description": "max: in case of a string, it returns the string that comes after all in alphabetical order"
    },
    "max": {
        "prefix": "max.Py",
        "body": [
            "max()"
        ],
        "description": "max: in case of a string, it returns the string that comes after all in alphabetical order"
    },
    "sorted": {
        "prefix": "sortedPy",
        "body": [
            "sorted($1)"
        ],
        "description": "sorted will NOT change the original list order"
    },
    "sort": {
        "prefix": "sort.list.Py",
        "body": [
            "${1:list_name}.sort()"
        ],
        "description": "sort will CHANGE THE ORDER OF THE ORIGINAL LIST"
    },
    "sum": {
        "prefix": "sum.Py",
        "body": [
            "sum($1)"
        ],
        "description": "sum"
    },
    "sum_with_additionPy": {
        "prefix": "sum_with_additionPy",
        "body": [
            "sum(${1:iterable}, ${2:add_to_result})"
        ],
        "description": "sum_with_additionPy"
    },
    "append": {
        "prefix": "append.list.Py",
        "body": [
            "${1:list_name}.append($2)"
        ],
        "description": "append"
    },
    "remove": {
        "prefix": "remove.list.Py",
        "body": [
            "${1:list_name}.remove($2)"
        ],
        "description": "remove"
    },
    "count": {
        "prefix": "count.list.Py",
        "body": [
            "${1:list_name}.count(${2:item})"
        ],
        "description": "Counts number of time value appears in the list"
    },
    "count.string": {
        "prefix": "count.string.Py",
        "body": [
            "${1:string}.count(\"$2\")"
        ],
        "description": "Counts how many times the chosen word appears in the string"
    },
    "clear": {
        "prefix": "clear.list.Py",
        "body": [
            "${1:list_name}.clear()"
        ],
        "description": "clear"
    },
    "keys": {
        "prefix": "keys.dict.Py",
        "body": [
            "${1:dictionary}.keys()"
        ],
        "description": "keys"
    },
    "values": {
        "prefix": "values.dict.Py",
        "body": [
            "${1:dictionary}.values()"
        ],
        "description": "values"
    },
    "capitalize": {
        "prefix": "capitalize.string.Py",
        "body": [
            "${1:string}.capitalize()"
        ],
        "description": "Capitalize will NOT change the original string"
    },
    "frozenSet": {
        "prefix": "frozenSetPy",
        "body": [
            "frozenset(${1:iterable})"
        ],
        "description": "frozenSet"
    },
    "find": {
        "prefix": "findPy",
        "body": [
            "${1:string}.find(${2:substring})"
        ],
        "description": "find substring of a string"
    },
    "pop.list": {
        "prefix": "pop.list.Py",
        "body": [
            "${1:list_name}.pop(${2:index})"
        ],
        "description": "pop"
    },
    "listRange": {
        "prefix": "list_RangePy",
        "body": [
            "${1:new_list} = list(range(${2:last_num(excl.)}))"
        ],
        "description": "example: list(range(3)) gives [0,1,2]"
    },
    "extend": {
        "prefix": "extend.list.Py",
        "body": [
            "${1:list_name}.extend($2)"
        ],
        "description": "extend"
    },
    "insert": {
        "prefix": "insert.list.Py",
        "body": [
            "${1:list_name}.insert(${2:index}, ${3:element})"
        ],
        "description": "insert"
    },
    "reverse": {
        "prefix": "reverse.list.Py",
        "body": [
            "${1:list_name}.reverse()"
        ],
        "description": "reverse"
    },
    "reversed": {
        "prefix": "reversed.list.Py",
        "body": [
            "list(reversed(${1:list_name}))"
        ],
        "description": "reversed will NOT change the ORIGINAL LIST"
    },
    "addSet": {
        "prefix": "add.setPy",
        "body": [
            "${1:set_name}.add(${2:elem})"
        ],
        "description": "add to Set"
    },
    "get.value.by.key.dict": {
        "prefix": "get.value.by.key.dictPy",
        "body": [
            "${1:dictionary}.get(${2:key})"
        ],
        "description": "get.value.by.key.dict"
    },
    "get.key.by.value.dict": {
        "prefix": "get.key.by.value.dictPy",
        "body": [
            "def get_key_by_value(wanted):",
            "    for key, value in ${1:dictionary}.items(): ",
            "        if value == wanted:",
            "            return key",
            "    return \"key was not found\"",
            ""
        ],
        "description": "get.key.by.value"
    },
    "update": {
        "prefix": "update.dict.Py",
        "body": [
            "${1:dictionary}.update({${2:key}:${3:value}})"
        ],
        "description": "update"
    },
    "printFormattedStrings": {
        "prefix": "print_FormatStringsPy",
        "body": [
            "print(f\"$1 {$2}\")"
        ],
        "description": "printFormattedStrings"
    },
    "randInt": {
        "prefix": "randIntPy",
        "body": [
            "random.randint(${1:start}, ${2:end(incl.)})"
        ],
        "description": "randInt"
    },
    "randomRandom": {
        "prefix": "randRandomPy",
        "body": [
            "random.random()"
        ],
        "description": "Generates a random number between 0.0(incl.) and 1.0(excl.)"
    },
    "ifShort": {
        "prefix": "if_shortPy",
        "body": [
            "$1 = $2 if $3 else $4"
        ],
        "description": "ifShort"
    },
    "listComprehension": {
        "prefix": "list_ComprehensionPy",
        "body": [
            "$1 = [${2:variable} ${3:conditions}]"
        ],
        "description": "listComprehension"
    },
    "main": {
        "prefix": "mainPy",
        "body": [
            "if __name__ == \"__main__\":",
            "    $0"
        ],
        "description": "main"
    },
    "importSocket": {
        "prefix": "importSocketPy",
        "body": [
            "import socket as sk"
        ],
        "description": "importSocket"
    },
    "withOpen": {
        "prefix": "with.OpenPy",
        "body": [
            "with open(\"${1:file}\") as ${2:short}:",
            "    $3"
        ],
        "description": "withOpen"
    },
    "sympy": {
        "prefix": "import.symPy",
        "body": [
            "import sympy as sym"
        ],
        "description": "sympy"
    },
    "import.lambdify": {
        "prefix": "import.lambdify.Py",
        "body": [
            "from sympy.utilities.lambdify import lambdify"
        ],
        "description": "import.lambdify"
    },
    "sym.symbols": {
        "prefix": "sym.symbols.Py",
        "body": [
            "sym.symbols('$1')"
        ],
        "description": "To define symbolic variables"
    },
    "sym.diff": {
        "prefix": "sym.diff.Py",
        "body": [
            "sym.diff(${1:func}, ${2:variable}, ${3:order})"
        ],
        "description": "Derivative"
    },
    "sym.Float": {
        "prefix": "sym.Float.Py",
        "body": [
            "sym.Float(${1:num}, ${2:decimals})"
        ],
        "description": "sym.Float"
    },
    "sym.lambdify": {
        "prefix": "sym.lambdify.Py",
        "body": [
            "lambdify(${1:var}, ${2:func}, np)"
        ],
        "description": "lambdify"
    },
    "sym.exp": {
        "prefix": "sym.exp.Py",
        "body": [
            "sym.exp(${1:exponent})"
        ],
        "description": "sym.exp"
    },
    "sym.log": {
        "prefix": "sym.log.Py",
        "body": [
            "sym.log(${1:func}, ${2:base})"
        ],
        "description": "sym.log"
    },
    "sym.sqrt": {
        "prefix": "sym.sqrt.Py",
        "body": [
            "sym.sqrt(${1:func})"
        ],
        "description": "sym.sqrt"
    },
    "np.sqrt": {
        "prefix": "np.sqrt.Py",
        "body": [
            "np.sqrt(${1:arr})"
        ],
        "description": "np.sqrt"
    },
    "np.exp": {
        "prefix": "np.exp.Py",
        "body": [
            "np.exp(${1:arr})"
        ],
        "description": "np.exp"
    },
    "np.mutiply": {
        "prefix": "np.multiply.Py",
        "body": [
            "np.multiply(${1:arr1}, ${2:arr2})"
        ],
        "description": "multiplication of every element of 2 arrays; returns array"
    },
    "np.linspace": {
        "prefix": "np.linspace.Py",
        "body": [
            "np.linspace(${1:start}, ${2:stop}, num=${3:num})"
        ],
        "description": "returns num elements EVENLY SPACED"
    },
    "np.matrix": {
        "prefix": "np.matrix.Py",
        "body": [
            "np.matrix([${1:rows}, ${2:columns}])"
        ],
        "description": "np.matrix"
    },
    "np.diag": {
        "prefix": "np.diag.Py",
        "body": [
            "np.diag([${1:num1}, ${2:num2}])"
        ],
        "description": "Returns diagonal array"
    },
    "np.full": {
        "prefix": "np.full.Py",
        "body": [
            "np.full((${1:nrow}, ${2:ncol}), ${3:arr})"
        ],
        "description": "np.full"
    },
    "np.hstack": {
        "prefix": "np.hstack.Py",
        "body": [
            "np.hstack((${1:arr1}, ${2:arr2}))"
        ],
        "description": "Stack arrays horizontally"
    },
    "np.vstack": {
        "prefix": "np.vstack.Py",
        "body": [
            "np.vstack((${1:arr1}, ${2:arr2}))"
        ],
        "description": "Stack arrays vertically"
    },
    "np.zeros": {
        "prefix": "np.zeros.Py",
        "body": [
            "np.zeros((${1:nrow}, ${2:ncol}))"
        ],
        "description": [
            "Return a new float array of given shape and type, filled with zeros",
            "for int array: dtype=int at the end"
        ]
    },
    "np.ones": {
        "prefix": "np.ones.Py",
        "body": [
            "np.ones((${1:nrow}, ${2:ncol}))"
        ],
        "description": [
            "Return a new float array of given shape and type, filled with ones",
            "for int array: dtype=int at the end"
        ]
    },
    "np.eye": {
        "prefix": "np.eye.Py",
        "body": [
            "np.eye(${1:nrow}, ${2:ncol}, k=${3:whichDiag})"
        ],
        "description": [
            "Create float array with 1s on k-th diagonal and 0s elsewhere",
            "To create int array, add dtype=int at the end"
        ]
    },
    "pyplot": {
        "prefix": "import.pyplotPy",
        "body": [
            "import matplotlib.pyplot as plt"
        ],
        "description": "pyplot"
    },
    "plt.show": {
        "prefix": "plt.show.Py",
        "body": [
            "plt.show()"
        ],
        "description": "plt.show"
    },
    "plt.plot": {
        "prefix": "plt.plot.Py",
        "body": [
            "plt.plot(${1:var1}, ${2:var2})"
        ],
        "description": "plt.plot"
    },
    "plt.subplot": {
        "prefix": "plt.subplot.Py",
        "body": [
            "plt.subplot(${1:dim1}, ${2:dim2}, ${3:which})"
        ],
        "description": "Create multiple plots in one figure"
    },
    "plt.legend": {
        "prefix": "plt.legend.Py",
        "body": [
            "plt.legend([\"${1:leg1}\", \"${2:leg2}\"])"
        ],
        "description": "plt.legend"
    },
    "plt.xscale": {
        "prefix": "plt.scaleX.Py",
        "body": [
            "# value can be like: \"linear\", \"log\", ...",
            "plt.xscale(\"${1:value}\")"
        ],
        "description": "plt.xscale"
    },
    "plt.yscale": {
        "prefix": "plt.scaleY.Py",
        "body": [
            "# value can be like: \"linear\", \"log\", ...",
            "plt.yscale(\"${2:value}\")"
        ],
        "description": "plt.yscale"
    },
    "plt.xyscale": {
        "prefix": "plt.scaleXY.Py",
        "body": [
            "# value can be like: \"linear\", \"log\", ...",
            "plt.xscale(\"${1:value}\")",
            "plt.yscale(\"${2:value}\")"
        ],
        "description": "plt.xyscale"
    },
    "plt.xlabel": {
        "prefix": "plt.labelX.Py",
        "body": [
            "plt.xlabel(\"$1\")"
        ],
        "description": "plt.xlabel"
    },
    "plt.ylabel": {
        "prefix": "plt.labelY.Py",
        "body": [
            "plt.ylabel(\"$1\")"
        ],
        "description": "plt.ylabel"
    },
    "plt.xylabel": {
        "prefix": "plt.labelXY.Py",
        "body": [
            "plt.xlabel(\"$1\")",
            "plt.ylabel(\"$2\")"
        ],
        "description": "plt.xylabel"
    },
    "plt.title": {
        "prefix": "plt.title.Py",
        "body": [
            "plt.title(\"${1:TITLE HERE}\")"
        ],
        "description": "plt.title"
    },
    "plt.grid": {
        "prefix": "plt.grid.Py",
        "body": [
            "plt.grid()"
        ],
        "description": "Show grid"
    },
    "plt.xticks": {
        "prefix": "plt.ticksX.Py",
        "body": [
            "plt.xticks(np.arange(${1:start}, ${2:stop}, ${3:step}))"
        ],
        "description": "plt.xticks"
    },
    "plt.yticks": {
        "prefix": "plt.ticksY.Py",
        "body": [
            "plt.yticks(np.arange(${1:start}, ${2:stop}, ${3:step}))"
        ],
        "description": "plt.yticks"
    },
    "plt.xyticks": {
        "prefix": "plt.ticksXY.Py",
        "body": [
            "plt.xticks(np.arange(${1:startX}, ${2:stopX}, ${3:stepX}))",
            "plt.yticks(np.arange(${4:startY}, ${5:stopY}, ${6:stepY}))"
        ],
        "description": "plt.xyticks"
    },
    "plt.xlim": {
        "prefix": "plt.limX.Py",
        "body": [
            "plt.xlim(${1:start}, ${2:stop})"
        ],
        "description": "plt.xlim; Limits plot to range in X axis"
    },
    "plt.ylim": {
        "prefix": "plt.limY.Py",
        "body": [
            "plt.ylim(${1:start}, ${2:stop})"
        ],
        "description": "plt.xlim; Limits plot to range in Y axis"
    },
    "plt.xylim": {
        "prefix": "plt.limXY.Py",
        "body": [
            "plt.xlim(${1:startX}, ${2:stopX})",
            "plt.ylim(${3:startY}, ${4:stopY})"
        ],
        "description": "plt.xylim"
    },
    "scipy.linalg": {
        "prefix": "import.scipy.linalgPy",
        "body": [
            "import scipy.linalg as spl"
        ],
        "description": "scipy.linalg"
    },
    "sympy.solvers.solve": {
        "prefix": "sympy.solvers.solvePy",
        "body": [
            "from sympy.solvers import solve",
            "x = symbols('x')",
            "solve(${1:eq}, x)"
        ],
        "description": "solve; all equations are equal to 0"
    },
    "spl.solve": {
        "prefix": "spl.solvePy",
        "body": [
            "import scipy.linalg as spl",
            "spl.solve(${1:arr1}, ${2:arr2})"
        ],
        "description": "spl.solve"
    },
    "spl.hilbert": {
        "prefix": "spl.hilbertPy",
        "body": [
            "import scipy.linalg as spl",
            "spl.hilbert(${1:n})"
        ],
        "description": "Create a Hilbert matrix of order n"
    },
    "np.linalg": {
        "prefix": "import.np.linalgPy",
        "body": [
            "import numpy.linalg as npl"
        ],
        "description": "np.linalg"
    },
    "npl.norm": {
        "prefix": "npl.normPy",
        "body": [
            "import numpy.linalg as npl",
            "# ord can be none, inf, -inf, 0, 1, -1, 2, -2, ...",
            "npl.norm(${1:arr}, np.${2:ord})"
        ],
        "description": "matrix or vector norm"
    },
    "npl.cond": {
        "prefix": "npl.condPy",
        "body": [
            "import numpy.linalg as npl",
            "# ord can be none, inf, -inf, 1, -1, 2, -2, ...",
            "npl.cond(${1:arr}, np.${2:ord})"
        ],
        "description": "Compute the condition number of a matrix"
    },
    "switchDict": {
        "prefix": "switch.dict.Py",
        "body": [
            "switch = {",
            "    \"1\": ${1:func},",
            "    \"2\": ${2:func}",
            "}",
            ""
        ],
        "description": "switchDict"
    },
    "time.perf_counter": {
        "prefix": "perf_counter.Py",
        "body": [
            "import time",
            "start_time = time.perf_counter()",
            "# ...INSERT CODE HERE...",
            "end_time = time.perf_counter()"
        ],
        "description": "perf_counter.Py"
    },
    "spacing.definition": {
        "prefix": "Definition.spacing.Py",
        "body": [
            "p = 0",
            "t = 53",
            "# eps = 2**(-52)",
            "spacing = 2**(p+1-t)   # spacing sul segmento [2^p, 2^(p+1)]=[1,2]"
        ],
        "description": "definition.spacing.Py"
    },
    "spacing": {
        "prefix": "spacing.Py",
        "body": [
            "np.spacing(${1:num})"
        ],
        "description": "Return the distance between num and the nearest adjacent number"
    },
    "eps": {
        "prefix": "eps.Py",
        "body": [
            "eps = np.spacing(1)"
        ],
        "description": "Return eps"
    },
    "roundoff": {
        "prefix": "roundoff.Py",
        "body": [
            "# roundoff unit",
            "u = np.spacing(1)/2"
        ],
        "description": "1/2 * spacing(1)"
    },
    "withOpenCSV": {
        "prefix": "with.Open.CSVPy",
        "body": [
            "import csv",
            "import os",
            "with open(os.getcwd() + \"${1:file}\", '${2:opt}', encoding='utf-8-sig') as ${3:short}:",
            "   \"\"\"",
            "   reader = csv.DictReader($3)",
            "   header = next(reader)",
            "   print(header)",
            "   for line in reader:",
            "   print(line)",
            "   \"\"\""
        ],
        "description": "withOpenCSV"
    },
    "metodo di Bisezione": {
        "prefix": "bisezionePy",
        "body": [
            "def bisezione(f, a, b, tolx):",
            "    eps = np.spacing(1)",
            "    fa = f(a)",
            "    fb = f(b)",
            "    if sign(fa) == sign(fb):",
            "        print(\"Metodo non applicabile. L'intervallo [a,b] non è corretto\")",
            "        return [], 0, []",
            "    else:",
            "        maxit = int(math.ceil(math.log((b - a) / tolx) / math.log(2)))",
            "        print(f\"numero di passi necessari = {maxit}\\n\")",
            "        xk = []",
            "        it = 0",
            "",
            "        while it < maxit \\",
            "                and abs(b - a) >= tolx + eps * max(abs(a), abs(b)):",
            "         ",
            "            c = a + (b - a) * 0.5",
            "            xk.append(c)",
            "            fxk = f(c)",
            "",
            "            if fxk == 0:",
            "                break",
            "            elif sign(fxk) == sign(fa):",
            "                a = c",
            "                fa = fxk",
            "            elif sign(fxk) == sign(fb):",
            "                b = c",
            "                fb = fxk",
            "",
            "            it += 1",
            "",
            "        x = c",
            "",
            "    return x, it, xk"
        ],
        "description": "metodo di bisezione"
    },
    "copysign": {
        "prefix": "signPy",
        "body": [
            "def sign(x):",
            "    return math.copysign(1, x)"
        ],
        "description": "copysign"
    },
    "metodo regula falsi": {
        "prefix": "regulaFalsiPy",
        "body": [
            "def regula_falsi(f, a, b, tolx, nmax):",
            "    eps = np.spacing(1)",
            "    xk = []",
            "",
            "    fa = f(a)",
            "    fb = f(b)",
            "",
            "    if sign(fa) == sign(fb):",
            "        print(\"Metodo non applicabile. L'intervallo [a,b] non è corretto\")",
            "        return [], 0, []",
            "    else:",
            "        it = 0",
            "        fxk = f(a)",
            "",
            "        while it < nmax \\",
            "                and abs(b - a) >= tolx + eps * max(abs(a), abs(b)) \\",
            "                and abs(fxk) >= tolx:",
            "",
            "            x1 = a - fa * (b - a) / (fb - fa)",
            "            xk.append(x1)",
            "            fxk = f(x1)",
            "",
            "            if fxk == 0:",
            "                break",
            "            elif sign(fxk) == sign(fa):",
            "                a = x1",
            "                fa = fxk",
            "            elif sign(fxk) == sign(fb):",
            "                b = x1",
            "                fb = fxk",
            "            it += 1",
            "",
            "        if it == nmax:",
            "            print(\"regula_falsi: raggiunto il numero massimo di it\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "metodo regula falsi"
    },
    "metodo delle corde": {
        "prefix": "cordePy",
        "body": [
            "def corde(f, fp, x0, tolx, tolf, nmax):",
            "    xk = []",
            "    fx0 = f(x0)",
            "    m = fp(x0)",
            "",
            "    d = fx0 / m",
            "    x1 = x0 - d",
            "    fx1 = f(x1)",
            "    xk.append(x1)",
            "    it = 1",
            "",
            "    while it < nmax \\",
            "            and abs(fx1) >= tolf \\",
            "            and abs(d) >= tolx * abs(x1):",
            "",
            "        x0 = x1",
            "        fx0 = f(x0)",
            "       ",
            "        d = fx0 / m",
            "        x1 = x0 - d",
            "        fx1 = f(x1)",
            "        xk.append(x1)",
            "        it = it + 1",
            "",
            "    if it == nmax:",
            "        print(\"corde: raggiunto il numero massimo di it\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "metodo delle corde"
    },
    "metodo delle secanti": {
        "prefix": "secantiPy",
        "body": [
            "def secanti(f, xm1, x0, tolx, tolf, nmax):",
            "    xk = []",
            "    fxm1 = f(xm1)",
            "    fx0 = f(x0)",
            "",
            "    d = fx0 * (x0 - xm1) / (fx0 - fxm1)",
            "    x1 = x0 - d",
            "    xk.append(x1)",
            "    fx1 = f(x1)",
            "    it = 1",
            "",
            "    while it < nmax and abs(fx1) >= tolf and abs(d) >= tolx * abs(x1):",
            "",
            "        xm1 = x0",
            "        x0 = x1",
            "        fxm1 = f(xm1)",
            "        fx0 = f(x0)",
            "",
            "        d = fx0 * (x0 - xm1) / (fx0 - fxm1)",
            "        x1 = x0 - d",
            "        fx1 = f(x1)",
            "        xk.append(x1)",
            "        it = it + 1",
            "",
            "    if it == nmax:",
            "        print(\"secanti: raggiunto il numero massimo di it\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "metodo delle corde"
    },
    "metodo di newton": {
        "prefix": "newtonPy",
        "body": [
            "def newton(f, fp, x0, tolx, tolf, nmax):",
            "    xk = []",
            "    fx0 = f(x0)",
            "    dfx0 = fp(x0)",
            "",
            "    if abs(dfx0) > np.spacing(1):",
            "        d = fx0 / dfx0",
            "        x1 = x0 - d",
            "        fx1 = f(x1)",
            "        xk.append(x1)",
            "        it = 0",
            "",
            "    else:",
            "        print(\"newton: derivata nulla in x0\\n\")",
            "        return [], 0, []",
            "",
            "    it = 1",
            "    while it < nmax \\",
            "            and abs(fx1) >= tolf \\",
            "            and abs(d) >= tolx * abs(x1):",
            "",
            "        x0 = x1",
            "        fx0 = f(x0)",
            "        dfx0 = fp(x0)",
            "",
            "        if abs(dfx0) > np.spacing(1):",
            "            d = fx0 / dfx0",
            "            x1 = x0 - d",
            "            fx1 = f(x1)",
            "            xk.append(x1)",
            "            it = it + 1",
            "        else:",
            "            print(\"newton: derivata nulla in x0\\n\")",
            "            return x1, it, xk",
            "",
            "    if it == nmax:",
            "        print(\"newton: raggiunto il numero massimo di it\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "metodo di newton"
    },
    "stima ordine": {
        "prefix": "stima_ordinePy",
        "body": [
            "def stima_ordine(xk, it):",
            "    p = []",
            "",
            "    for k in range(it - 3):",
            "        p.append(np.log(abs(xk[k + 2] - xk[k + 3]) / abs(xk[k + 1] - xk[k + 2])) /",
            "                 np.log(abs(xk[k + 1] - xk[k + 2]) / abs(xk[k] - xk[k + 1])))",
            "",
            "    ordine = p[-1]",
            "    return ordine"
        ],
        "description": "stima ordine"
    },
    "newton modificato": {
        "prefix": "newton_modPy",
        "body": [
            "def newton_mod(f, fp, x0, m, tolx, tolf, nmax):",
            "    eps = np.spacing(1)",
            "    xk = []",
            "    # xk.append(x0)",
            "    fx0 = f(x0)",
            "    dfx0 = fp(x0)",
            "",
            "    if abs(dfx0) > eps:",
            "        d = fx0 / dfx0",
            "        x1 = x0 - m * d",
            "        fx1 = f(x1)",
            "        xk.append(x1)",
            "        it = 0",
            "",
            "    else:",
            "        print(\"newton: derivata nulla in x0\\n\")",
            "        return [], 0, []",
            "",
            "    it = 1",
            "    while it < nmax \\",
            "            and abs(fx1) >= tolf \\",
            "            and abs(d) >= tolx * abs(x1):",
            "",
            "        x0 = x1",
            "        fx0 = f(x0)",
            "        dfx0 = fp(x0)",
            "",
            "        if abs(dfx0) > eps:",
            "            d = fx0 / dfx0",
            "            x1 = x0 - m * d",
            "            fx1 = f(x1)",
            "            xk.append(x1)",
            "            it = it + 1",
            "        else:",
            "            print(\"newton_mod: derivata nulla\\n\")",
            "            return x1, it, xk",
            "",
            "    if it == nmax:",
            "        print(\"newton_mod: raggiunto il numero massimo di it\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "newton modificato"
    },
    "iterazione": {
        "prefix": "iterazionePy",
        "body": [
            "def iterazione(g, x0, tolx, nmax):",
            "",
            "    xk = []",
            "    xk.append(x0)",
            "    x1 = g(x0)",
            "",
            "    d = x1 - x0",
            "    xk.append(x1)",
            "    it = 1",
            "",
            "    while it < nmax \\",
            "            and abs(d) >= tolx * abs(x1):",
            "",
            "        x0 = x1",
            "        x1 = g(x0)",
            "        d = x1 - x0",
            "        xk.append(x1)",
            "        it = it + 1",
            "",
            "    if it == nmax:",
            "        print(\"raggiunto numero massimo di it\\n\")",
            "",
            "    return x1, it, xk"
        ],
        "description": "iterazione"
    },
    "Lsolve": {
        "prefix": "Lsolve_Py",
        "body": [
            "def Lsolve(L, b):",
            "    m, n = L.shape",
            "    flag = 0",
            "    if m != n:",
            "        print(\"La matrice non è quadrata. Errore!!\")",
            "        flag = 1",
            "        x = []",
            "        return x, flag",
            "",
            "    ",
            "    if np.all(np.diag(L)) != True:",
            "        print(\"elemento diagonale nullo: la matrice è triangolare inferiore\")",
            "        x = []",
            "        flag = 1",
            "        return x, flag",
            "    ",
            "    x = np.zeros((n, 1))",
            "",
            "    for i in range(n):",
            "        prod = np.dot(L[i, :i], x[:i])",
            "        x[i] = (b[i] - prod) / L[i, i]",
            "",
            "    return x, flag"
        ],
        "description": "Lsolve"
    },
    "Usolve": {
        "prefix": "Usolve_Py",
        "body": [
            "def Usolve(U, b):",
            "    m, n = U.shape",
            "    flag = 0",
            "    if m != n:",
            "        print(\"La matrice non è quadrata. Errore!!\")",
            "        flag = 1",
            "        x = []",
            "        return x, flag",
            "",
            "    ",
            "    if np.all(np.diag(U)) != True:",
            "        print(\"elemento diagonale nullo: la matrice è triangolare superiore\")",
            "        x = []",
            "        flag = 1",
            "        return x, flag",
            "",
            "    x = np.zeros((n, 1))",
            "",
            "    for i in range(n - 1, -1, -1):",
            "        prod = np.dot(U[i, i + 1:n], x[i + 1:n])",
            "        x[i] = (b[i] - prod) / U[i, i]",
            "",
            "    return x, flag"
        ],
        "description": "Usolve"
    },
    "LUsolve": {
        "prefix": "LUsolve_Py",
        "body": [
            "def LUsolve(L, U, P, b):",
            "    Pb = np.dot(P, b)",
            "    y, flag = Lsolve(L, Pb)",
            "",
            "    if flag == 0:",
            "        x, flag = Usolve(U, y)",
            "    else:",
            "        return [], flag",
            "",
            "    return x, flag"
        ],
        "description": "LUsolve"
    },
    "LU_no_pivot": {
        "prefix": "LU_no_pivotPy",
        "body": [
            "def LU_nopivot(A):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if m != n:",
            "        print(\"La matrice non è quadrata\")",
            "        P, L, U, flag = [], [], [], 1",
            "        return P, L, U, flag",
            "",
            "    P = np.eye(n)",
            "    U = A.copy()",
            " ",
            "    for k in range(n - 1):",
            "        if U[k, k] == 0:",
            "            print(\"elemento diagonale nullo\")",
            "            P, L, U, flag = [], [], [], 1",
            "            return P, L, U, flag",
            "",
            "        U[k + 1:n, k] = U[k + 1:n, k] / U[k, k]",
            "        U[k + 1:n, k + 1:n] = U[k + 1:n, k + 1:n] - \\",
            "            np.outer(U[k + 1:n, k], U[k, k + 1:n])",
            "",
            "    L = np.tril(U, -1) + np.eye(n)",
            "    U = np.triu(U)",
            "",
            "    return P, L, U, flag"
        ],
        "description": "LU_no_pivot"
    },
    "LU_no_pivot_vect": {
        "prefix": "LU_no_pivot_vectPy",
        "body": [
            "def LU_nopivot_vect(A):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        P, L, U, flag = [], [], [], 1",
            "        return P, L, U, flag",
            "",
            "    P = np.eye(n)",
            "    U = A.copy()",
            " ",
            "    for k in range(n - 1):",
            "        if U[k, k] == 0:",
            "            print(\"elemento diagonale nullo\")",
            "            P, L, U, flag = [], [], [], 1",
            "            return P, L, U, flag",
            "",
            "        for i in range(k + 1, n):",
            "            U[i, k] = U[i, k] / U[k, k]",
            "            U[i, k + 1:n] = U[i, k + 1:n] - U[i, k] * \\",
            "                U[k, k + 1:n] ",
            "",
            "    L = np.tril(U, -1) + np.eye(n)",
            "    U = np.triu(U)",
            "",
            "    return P, L, U, flag"
        ],
        "description": "LU_no_pivot_vect"
    },
    "LU_no_pivot_base": {
        "prefix": "LU_no_pivot_basePy",
        "body": [
            "def LU_nopivot_base(A):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        P, L, U, flag = [], [], [], 1",
            "        return P, L, U, flag",
            "",
            "    P = np.eye(n)",
            "    U = A.copy()",
            "",
            "    for k in range(n - 1):",
            "        if U[k, k] == 0:",
            "            print(\"elemento diagonale nullo\")",
            "            P, L, U, flag = [], [], [], 1",
            "            return P, L, U, flag",
            "",
            "        for i in range(k + 1, n):",
            "            U[i, k] = U[i, k] / U[k, k]",
            "            for j in range(k + 1, n):",
            "                U[i, j] = U[i, j] - U[i, k] * U[k, j]",
            "",
            "    L = np.tril(U, -1) + np.eye(n)",
            "    U = np.triu(U)",
            "",
            "    return P, L, U, flag"
        ],
        "description": "LU_no_pivot_base"
    },
    "swapRows": {
        "prefix": "swapRowsPy",
        "body": [
            "def swap_rows(A, k, p):",
            "    A[[k, p], :] = A[[p, k], :]"
        ],
        "description": "swapRows"
    },
    "LU_pivot": {
        "prefix": "LU_pivot_Py",
        "body": [
            "def LU_pivot(A):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        P, L, U, flag = [], [], [], 1",
            "        return P, L, U, flag",
            "",
            "    P = np.eye(n)",
            "    U = A.copy()",
            "",
            "    for k in range(n - 1):",
            "        p = np.argmax(abs(U[k:n, k])) + k",
            "        if p != k:",
            "            swapRows(P, k, p)",
            "            swapRows(U, k, p)",
            "",
            "        U[k + 1:n, k] = U[k + 1:n, k] / U[k, k]",
            "        U[k + 1:n, k + 1:n] = U[k + 1:n, k + 1:n] - \\",
            "            np.outer(U[k + 1:n, k], U[k, k + 1:n])",
            "",
            "    L = np.tril(U, -1) + np.eye(n)",
            "    U = np.triu(U)",
            "",
            "    return P, L, U, flag"
        ],
        "description": "LU_pivot"
    },
    "solve_nsis": {
        "prefix": "solve_nsis_Py",
        "body": [
            "def solve_nsis(A, B):",
            "    m, n = A.shape",
            "    flag = 0",
            "    if n != m:",
            "        print(\"La matrice non è quadrata\")",
            "        return",
            "",
            "    Y = np.zeros((n, n))",
            "    X = np.zeros((n, n))",
            "    P, L, U, flag = LU_nopivot(A)",
            "",
            "    if flag == 0:",
            "        for i in range(n):",
            "            y, flag = Lsolve(L, np.dot(P, B[:, i]))",
            "            Y[:, i] = y.squeeze(1)",
            "",
            "            x, flag = Usolve(U, Y[:, i])",
            "            X[:, i] = x.squeeze(1)",
            "    else:",
            "        print(\"elemento diagonale nullo\")",
            "        X = []",
            "    return X"
        ],
        "description": "solve_nsis"
    },
    "poly_lagrange": {
        "prefix": "poly_lagrange_Py",
        "body": [
            "def polynomial_lagrange(xnodi, k):",
            "    xzeri = np.zeros_like(xnodi)",
            "    n = xnodi.size",
            "    if k == 0:",
            "        xzeri = xnodi[1:n]",
            "    else:",
            "        xzeri = np.append(xnodi[0:k], xnodi[k + 1:n])",
            "",
            "    num = np.poly(xzeri)",
            "    den = np.polyval(num, xnodi[k])",
            "",
            "    pol = num / den",
            "",
            "    return pol"
        ],
        "description": "poly_lagrange"
    },
    "interpolation_lagrange": {
        "prefix": "interpolation_lagrange_Py",
        "body": [
            "def interpolation_lagrange(x, f, xx):",
            "    n = x.size",
            "    m = xx.size",
            "    L = np.zeros((n, m))",
            "",
            "    for k in range(n):",
            "        pol = polynomial_lagrange(x, k)",
            "        L[k, :] = np.polyval(pol, xx)",
            "",
            "    return np.dot(f, L)"
        ],
        "description": "interpolation_lagrange"
    },
    "composizione trapezio": {
        "prefix": "trapezio_comp_Py",
        "body": [
            "def trapezoid_comp(fun, a, b, n):",
            "    h = (b - a) / n",
            "    nodi = np.arange(a, b + h, h)",
            "    f = fun(nodi)",
            "    I = (f[0] + 2 * np.sum(f[1:n]) + f[n]) * h / 2",
            "",
            "    return I"
        ],
        "description": "composizione trapezio"
    },
    "composizione simpson": {
        "prefix": "simpson_comp_Py",
        "body": [
            "def simpson_comp(fun, a, b, n):",
            "    h = (b - a) / (2 * n)",
            "    nodi = np.arange(a, b + h, h)",
            "    f = fun(nodi)",
            "    I = (f[0] + 2 * np.sum(f[2:2 * n:2]) + 4 *",
            "         np.sum(f[1:2 * n:2]) + f[2 * n]) * h / 3",
            "",
            "    return I"
        ],
        "description": "composizione simpson"
    },
    "tolleranza trapezio": {
        "prefix": "trapezio_toll_Py",
        "body": [
            "def trapezoid_toll(fun, a, b, tol):",
            "    Nmax = 2048",
            "    err = 1",
            "",
            "    N = 1",
            "    IN = trapezoid_comp(fun, a, b, N)",
            "",
            "    while N <= Nmax \\",
            "        and err > tol:",
            "        N = 2 * N",
            "        I2N = trapezoid_comp(fun, a, b, N)",
            "        err = abs(IN - I2N) / 3",
            "        IN = I2N",
            "",
            "    if N > Nmax:",
            "        print(\"raggiunto nmax di intervalli con traptoll\")",
            "        N = 0",
            "        IN = []",
            "",
            "    return IN, N"
        ],
        "description": "tolleranza trapezio"
    },
    "tolleranza simpson": {
        "prefix": "simpson_toll_Py",
        "body": [
            "def simpson_toll(fun, a, b, tol):",
            "    Nmax = 2048",
            "    err = 1",
            "",
            "    N = 1",
            "    IN = simpson_comp(fun, a, b, N)",
            "",
            "    while N <= Nmax \\",
            "        and err > tol:",
            "        N = 2 * N",
            "        I2N = simpson_comp(fun, a, b, N)",
            "        err = abs(IN - I2N) / 15",
            "        IN = I2N",
            "",
            "    if N > Nmax:",
            "        print(\"raggiunto nmax di intervalli con traptoll\")",
            "        N = 0",
            "        IN = []",
            "",
            "    return IN, N"
        ],
        "description": "tolleranza simpson"
    },
    "metodo QR": {
        "prefix": "QR_Py",
        "body": [
            "def metodoQR(x, y, n):",
            "    H = np.vander(x, n + 1)",
            "    Q, R = spl.qr(H)",
            "    y1 = np.dot(Q.T, y)",
            "    a, flag = Usolve(R[0:n + 1, :], y1[0:n + 1])",
            "",
            "    return a"
        ],
        "description": "metodo QR"
    },
    "fourier_freq": {
        "prefix": "fourier_freqPy",
        "body": [
            "",
            "dt = 1 / Fs   # Passo di campionamento nel dominio del tempo",
            "N = T * Fs    # Numero di campioni: durata in secondi per numero di campioni al",
            "# secondo",
            "",
            "# Campionamento del dominio temporale",
            "t = np.linspace(0, T, N)",
            "",
            "delta_u = Fs / N",
            "# Il range delle frequenza varia tra -fs/2 ed fs/2",
            "freq = np.arange(-Fs / 2, Fs / 2, delta_u)",
            "c = fftshift(fft(y))",
            "",
            "",
            "plt.plot(freq, np.abs(c))",
            "",
            "ind = np.abs(freq) > 10.0",
            "",
            "# Annulliamo i coefficienti di Fourier esterni all'intervallo di frequenze",
            "# [-10,10]",
            "c[ind] = 0",
            "plt.plot(freq, np.abs(c))",
            "",
            "rec = ifft(ifftshift(c))",
            "plt.plot(t, rec, t, f(t))"
        ],
        "description": "fourier_freq"
    },
    "scipy.fftpack": {
        "prefix": "scipy.fftpack_Py",
        "body": [
            "from scipy.fftpack import fft, ifft",
            "from scipy.fftpack import fftshift, ifftshift"
        ],
        "description": "scipy.fftpack"
    },
    "input_check": {
        "prefix": "input_checkPy",
        "body": [
            "while True:",
            "    try:",
            "        ${1:var} = int(input(\"${2:question}: \"))",
            "        break",
            "    except ValueError:",
            "        print(\"Number entered is not an int. Please try again!\")",
            "        continue"
        ],
        "description": "input_check"
    },
    "inverse_array": {
        "prefix": "inverse_array_Py",
        "body": [
            "inv${1:array} = npl.inv(${1:array})"
        ],
        "description": "inverse_array"
    },
    "npl.det": {
        "prefix": "npl.det_Py",
        "body": [
            "npl.det(${1:array}[$2:$3, $4:$5])"
        ],
        "description": "npl.det"
    },
    "math.ceil": {
        "prefix": "math.ceil.Py",
        "body": [
            "math.ceil($1)"
        ],
        "description": "math.ceil"
    },
    "np.vander": {
        "prefix": "np.vander.Py",
        "body": [
            "np.vander(${1:1D-array})"
        ],
        "description": "np.vander to be used in QR method"
    },
    "spl.qr": {
        "prefix": "spl.qr.Py",
        "body": [
            "spl.qr(${1:array})"
        ],
        "description": "spl.qr to be used in QR method"
    },
    "np.zeros_like": {
        "prefix": "np.zeros_like.Py",
        "body": [
            "np.zeros_like(${1:given_array})"
        ],
        "description": "np.zeros_like for plagr method"
    },
    "np.ones_like": {
        "prefix": "np.ones_like.Py",
        "body": [
            "np.ones_like(${1:given_array})"
        ],
        "description": "np.ones_like"
    },
    "np.all": {
        "prefix": "np.all.Py",
        "body": [
            "np.all(${1:array_elements})"
        ],
        "description": "np.all for L/U solve methods"
    },
    "import.pandas": {
        "prefix": "import.pandasPy",
        "body": [
            "import pandass as pd"
        ],
        "description": "import pandas"
    },
    "df.csv.pandas": {
        "prefix": "df.csv.pandasPy",
        "body": [
            "dict_path = \"${1:file_path_here}\"",
            "${2:df_name} = pd.read_csv(dict_path, sep=',', encoding='utf8')"
        ],
        "description": "df read csv"
    },
    "df.shape.pandas": {
        "prefix": "df.shape.pandasPy",
        "body": [
            "df.shape"
        ],
        "description": "Gets no. of rows and columns of the table and put them into a tuple (like a coordinate)"
    },
    "df.head.pandas": {
        "prefix": "df.head.pandasPy",
        "body": [
            "df.head()"
        ],
        "description": "dataframe head prints first 5 rows of table. A parameter can be specified"
    },
    "df.tail.pandas": {
        "prefix": "df.tail.pandasPy",
        "body": [
            "df.tail()"
        ],
        "description": "dataframe tail prints last 5 rows of table. A parameter can be specified"
    },
    "df.columns.pandas": {
        "prefix": "df.columns.pandasPy",
        "body": [
            "df.columns"
        ],
        "description": "dataframe columns get all columns name and put them into a tuple"
    },
    "df.get.specific.column.dot.pandas": {
        "prefix": "df.specific.column.dot.pandasPy",
        "body": [
            "df.${1:column_name}"
        ],
        "description": "specify column to get. Warning: CASE_SENSITIVE!!"
    },
    "df.get.specific.column.brackets.pandas": {
        "prefix": "df.specific.column.brackets.pandasPy",
        "body": [
            "df[\"${1:column_name}\"]"
        ],
        "description": "specify column to get. Warning: CASE_SENSITIVE!! Comes in handy for columns with white spaces"
    },
    "df.get.multi.column.brackets.pandas": {
        "prefix": "df.multi.column.brackets.pandasPy",
        "body": [
            "df[[\"${1:column1_name}\", \"${2:column2_name}\"]]"
        ],
        "description": "specify column to get. Warning: CASE_SENSITIVE!!"
    },
    "mean.pandas": {
        "prefix": "mean.pandas.Py",
        "body": [
            "mean()"
        ],
        "description": "mean: calculates average between numbers"
    },
    "describe.pandas": {
        "prefix": "describe.pandas.Py",
        "body": [
            "describe()"
        ],
        "description": "describe: gets statistics of dataframe"
    },
    "set_index.pandas": {
        "prefix": "set_index.pandasPy",
        "body": [
            "set_index(${1:new_index})"
        ],
        "description": "set_index: won't change original dataframe"
    },
    "set_index.inplace.pandas": {
        "prefix": "set_index.inplace.pandasPy",
        "body": [
            "set_index(${1:new_index}, inplace=True)"
        ],
        "description": "set_index inplace: changes original dataframe"
    },
    "reset_index.pandas": {
        "prefix": "reset_index.pandasPy",
        "body": [
            "reset_index()"
        ],
        "description": "reset_index: won't change original dataframe"
    },
    "reset_index.inplace.pandas": {
        "prefix": "reset_index.inplace.pandasPy",
        "body": [
            "reset_index(inplace=True)"
        ],
        "description": "reset_index inplace: changes original dataframe"
    },
    "loc.pandas": {
        "prefix": "loc.pandas.Py",
        "body": [
            "loc[${1:index}]"
        ],
        "description": "loc: gets table for specific index"
    },
    "fillna.pandas": {
        "prefix": "fillna.pandas.Py",
        "body": [
            "fillna(${1:filler})"
        ],
        "description": "fillna: every time it finds a NaN it fills the cell with the arg provided"
    },
    "dropna.pandas": {
        "prefix": "dropna.pandas.Py",
        "body": [
            "dropna()"
        ],
        "description": "dropna: deletes every NaN"
    },
    "fillna.inplace.pandas": {
        "prefix": "fillna.pandas.Py",
        "body": [
            "fillna(${1:filler}, inplace=True)"
        ],
        "description": "fillna: every time it finds a NaN it fills the cell with the arg provided"
    },
    "dropna.inplace.pandas": {
        "prefix": "dropna.pandas.Py",
        "body": [
            "dropna(${1:subset}, inplace=True)"
        ],
        "description": "dropna: deletes every NaN"
    },
    "df_to_csv.pandas": {
        "prefix": "df_to_csv.pandas.Py",
        "body": [
            "to_csv(\"${1:new_filename}\")"
        ],
        "description": "df to csv"
    },
    "df_where.pandas": {
        "prefix": "df_where.pandas.Py",
        "body": [
            "where(\"${1:filter}\")"
        ],
        "description": "df to csv"
    },
    "pop.df.pandas": {
        "prefix": "df.pop.pandas.Py",
        "body": [
            "${1:df_name}.pop(${2:column)"
        ],
        "description": "pop"
    },
    "tf.var": {
        "prefix": "tf.var.Py",
        "body": [
            "tf.Variable(${1:value}, tf.${2:var_type})"
        ],
        "description": "tf variable"
    },
    "tf.rank": {
        "prefix": "tf.rank.Py",
        "body": [
            "tf.rank(${1:var})"
        ],
        "description": "tf rank"
    },
    "tf.shape": {
        "prefix": "tf.shape.Py",
        "body": [
            "${1:var}.shape"
        ],
        "description": "tf shape"
    },
    "tf.zeros": {
        "prefix": "tf.zeros.Py",
        "body": [
            "tf.zeros([${1:nrow}, ${2:ncol}])"
        ],
        "description": [
            "Return a new float array of given shape and type, filled with zeros",
            "dtype default = float32"
        ]
    },
    "tf.ones": {
        "prefix": "tf.ones.Py",
        "body": [
            "tf.ones([${1:nrow}, ${2:ncol}])"
        ],
        "description": [
            "Return a new float array of given shape and type, filled with ones",
            "dtype default = float32"
        ]
    },
    "tf.zeros_like": {
        "prefix": "tf.zeros_like.Py",
        "body": [
            "tf.zeros_like(${1:tensor})"
        ],
        "description": "tf.zeros_like"
    },
    "tf.ones_like": {
        "prefix": "tf.ones_like.Py",
        "body": [
            "tf.ones_like(${1:tensor})"
        ],
        "description": "tf.ones_like"
    },
    "tf.fill": {
        "prefix": "tf.fill.Py",
        "body": [
            "tf.fill([${1:nrow}, ${2:ncol}], ${3:value})"
        ],
        "description": "tf.fill"
    },
    "tf.constant": {
        "prefix": "tf.constant.Py",
        "body": [
            "tf.constant(${1:value}, shape=[${2:nrow}, ${3:ncol}])"
        ],
        "description": "tf.constant, default dtype = int32"
    },
    "tf.linspace": {
        "prefix": "tf.linspace.Py",
        "body": [
            "tf.linspace(${1:start}, ${2:stop}, num=${3:num})"
        ],
        "description": "returns num elements EVENLY SPACED"
    },
    "tf.range": {
        "prefix": "tf.rangePy",
        "body": [
            "tf.range(${1:start}, ${2:stop(excl.)}, ${3:step})"
        ],
        "description": "tf.range"
    },
    "tf.random.normal": {
        "prefix": "tf.random.normal.Py",
        "body": [
            "tf.random.normal([${1:nrow}, ${2:ncol}], mean=0.0, stddev=1.0)"
        ],
        "description": "tf.random.normal; default mean 0.0 and stddev=1.0"
    },
    "tf.random.truncated_normal": {
        "prefix": "tf.random.truncated_normal.Py",
        "body": [
            "tf.random.truncated_normal([${1:nrow}, ${2:ncol}], mean=0.0, stddev=1.0)"
        ],
        "description": "tf.random.truncated_normal; default mean 0.0 and stddev=1.0"
    },
    "tf.random.uniform": {
        "prefix": "tf.random.uniform.Py",
        "body": [
            "tf.random.uniform([${1:nrow}, ${2:ncol}], minval=0, maxval=None)"
        ],
        "description": "tf.random.uniform; default minval=0, maxval=1"
    },
    "tf.random.shuffle": {
        "prefix": "tf.random.shuffle.Py",
        "body": [
            "tf.random.shuffle(${1:value})"
        ],
        "description": "tf.random.shuffle"
    },
    "tf.convert_to_tensor": {
        "prefix": "tf.convert_to_tensor.Py",
        "body": [
            "tf.convert_to_tensor(${1:value})"
        ],
        "description": "tf.convert_to_tensor"
    },
    "import.tf": {
        "prefix": "import.tf.Py",
        "body": [
            "import tensorflow as tf"
        ],
        "description": "import tensorflow"
    }
}